<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MPS Connect — AI Approval Workflow System (Beta)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Optional local overrides. Create env.js (gitignored) to set window.API_BASE, window.API_KEY, etc. -->
  <script src="env.js"></script>
  <style>
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .badge { padding: 0.125rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; background-color: rgb(243 244 246); border: 1px solid rgb(229 231 235); }
    .scroll-pane { max-height: 18rem; overflow: auto; }
    .btn { padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid #d1d5db; }
    .btn-primary { padding: 0.5rem 0.75rem; border-radius: 0.5rem; background-color: #2563eb; color: white; }
    .btn-ghost { padding: 0.25rem 0.5rem; font-size: 0.875rem; border-radius: 0.25rem; border: 1px solid #d1d5db; }
    .btn-green { padding: 0.25rem 0.5rem; font-size: 0.875rem; border-radius: 0.25rem; background-color: #059669; color: white; }
    .btn-red { padding: 0.25rem 0.5rem; font-size: 0.875rem; border-radius: 0.25rem; background-color: #dc2626; color: white; }
    .btn-amber { padding: 0.25rem 0.5rem; font-size: 0.875rem; border-radius: 0.25rem; background-color: #f59e0b; color: white; }
    .typing-dot-1 { animation-delay: 0s; }
    .typing-dot-2 { animation-delay: 0.1s; }
    .typing-dot-3 { animation-delay: 0.2s; }
    .progress-bar { width: 0%; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-6xl mx-auto p-4 sm:p-6">
    <header class="mb-4 sm:mb-6">
      <h1 class="text-2xl font-semibold">MPS Connect — AI-Powered Case Assistant (Beta)</h1>
      <p class="text-sm text-gray-600">
        AI-powered case classification with confidence-based approval recommendations for case writers and authorities.
        <span class="font-semibold">Avoid PII during public testing.</span>
      </p>
      <p id="urlNotice" class="text-xs text-amber-700 mt-1 hidden">Settings loaded from URL parameters.</p>
    </header>

    <!-- Settings (Hidden for case writers) -->
    <section class="bg-white shadow-sm rounded-xl p-4 sm:p-5 mb-6 border hidden">
      <!-- Label Search Section (Hidden by default) -->
      <div id="labelSearchSection" class="mt-4 p-4 bg-gray-50 rounded-lg hidden">
        <h3 class="font-semibold mb-3">Label Search</h3>
        <input id="labelSearch" class="w-full rounded-lg border px-3 py-2" placeholder="Search for labels..." />
        <div id="labelsStatus" class="text-xs text-gray-600 mt-2">Ready to search</div>
        <div id="labelsList" class="mt-2 max-h-40 overflow-y-auto"></div>
      </div>
      <h2 class="font-semibold mb-3">API Settings</h2>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <label class="block">
          <span class="text-sm">API Base URL</span>
          <input id="apiBase" class="mt-1 w-full rounded-lg border px-3 py-2"
                 placeholder="https://mps-connect-api-987575541268.asia-southeast1.run.app" />
        </label>
        <label class="block">
          <span class="text-sm">X-API-Key</span>
          <input id="apiKey" class="mt-1 w-full rounded-lg border px-3 py-2"
                 placeholder="mps-85-whampoa" />
        </label>
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mt-4">
        <label class="block">
          <span class="text-sm">Confidence Threshold</span>
          <input id="confidenceThreshold" type="number" step="0.01" value="0.2" class="mt-1 w-full rounded-lg border px-3 py-2" />
        </label>
        <label class="block">
          <span class="text-sm">Max Categories</span>
          <input id="maxCategories" type="number" value="6" class="mt-1 w-full rounded-lg border px-3 py-2" />
        </label>
        <label class="block">
          <span class="text-sm">Max Sub-Categories</span>
          <input id="maxSubCategories" type="number" value="10" class="mt-1 w-full rounded-lg border px-3 py-2" />
        </label>
      </div>
      <div class="flex items-center gap-4 mt-3">
        <label class="inline-flex items-center gap-2">
          <input id="usePriors" type="checkbox" class="rounded" />
          <span class="text-sm">Use co-occurrence priors</span>
        </label>
        <div class="ml-auto flex gap-2">
          <button id="btnSave" class="px-3 py-2 rounded-lg bg-gray-900 text-white">Save</button>
          <button id="btnHealth" class="px-3 py-2 rounded-lg border">Check /healthz</button>
        </div>
      </div>
      <p id="healthOut" class="text-xs text-gray-600 mt-2"></p>
    </section>

    <!-- Case Analysis -->
    <section class="bg-white shadow-sm rounded-xl p-4 sm:p-5 mb-6 border">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold">Case Analysis</h2>
        <div class="flex items-center gap-2">
          <span class="text-sm text-gray-600">Mode:</span>
          <button id="toggleMode" class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700">
            Switch to Guided Chat
          </button>
        </div>
      </div>
      
      <!-- Single-shot Analysis Mode -->
      <div id="singleShotMode">
        <textarea id="caseText" rows="5" class="w-full rounded-lg border px-3 py-2" placeholder="Describe the case in natural SG English…"></textarea>
        <div class="mt-3 flex gap-2">
          <button id="btnPredict" class="btn-primary">Analyze Case</button>
          <button id="btnClear" class="btn">Clear</button>
        </div>
      </div>
      
      <!-- Guided Chat Mode -->
      <div id="guidedChatMode" class="hidden">
        <div class="mb-4 p-4 bg-blue-50 rounded-lg border">
          <h3 class="font-medium text-blue-800 mb-2">MPS Connect Assistant</h3>
          <p class="text-sm text-blue-600">I'll help you collect the necessary information to generate a proper letter. Let's start with the basic details.</p>
          <div id="chatProgress" class="mt-3 hidden">
            <div class="flex items-center justify-between text-xs text-gray-600 mb-1">
              <span>Progress</span>
              <span id="progressText">0 / 0</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2">
              <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300 progress-bar"></div>
            </div>
          </div>
        </div>
        <div id="chatContainer" class="h-64 overflow-y-auto border rounded-lg p-4 bg-gray-50 mb-4">
          <div id="chatMessages" class="space-y-3"></div>
        </div>
        <div class="flex gap-2">
          <div class="flex-1 relative">
            <input id="chatInput" type="text" class="w-full rounded-lg border px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all" placeholder="Type your response here..." disabled>
            <div id="charCount" class="absolute bottom-1 right-2 text-xs text-gray-400 hidden">0/500</div>
          </div>
          <button id="btnSendChat" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors" disabled>
            <span id="sendText">Send</span>
            <span id="sendingText" class="hidden">Sending...</span>
          </button>
          <button id="btnResetChat" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 transition-colors">Reset</button>
        </div>
        
        <!-- Quick Action Buttons -->
        <div id="quickActions" class="mt-3 hidden">
          <div class="text-xs text-gray-600 mb-2">Quick responses:</div>
          <div id="quickActionButtons" class="flex flex-wrap gap-2">
            <!-- Quick action buttons will be populated here -->
          </div>
        </div>
        
        <!-- Typing Indicator -->
        <div id="typingIndicator" class="mt-2 hidden">
          <div class="flex items-center space-x-2 text-gray-500">
            <div class="flex space-x-1">
              <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce typing-dot-1"></div>
              <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce typing-dot-2"></div>
              <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce typing-dot-3"></div>
            </div>
            <span class="text-xs">MPS Connect is typing...</span>
          </div>
        </div>
      </div>
      
      <p id="errMsg" class="text-sm text-red-600 mt-2 hidden"></p>
    </section>

    <!-- AI Analysis Results -->
    <section class="bg-white shadow-sm rounded-xl p-4 sm:p-5 mb-6 border">
      <h2 class="font-semibold mb-3">AI Analysis Results</h2>
      
      <!-- Main Categories (LEFT) -->
      <div id="mainCategories" class="mb-6 hidden">
        <h3 class="font-medium mb-3">Main Categories Detected</h3>
        <div id="mainCategoryGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <!-- Main categories will be populated here -->
        </div>
      </div>

      <!-- Selected Category Details (RIGHT) -->
      <div id="selectedCategoryDetails" class="mb-6">
        <h3 class="font-medium mb-3">Sub-Categories for Letter Generation</h3>
        <div id="subCategoryList" class="space-y-3">
          <!-- Sub-categories will be populated here -->
        </div>
      </div>

      <!-- Legacy Result Containers (for backward compatibility) -->
      <div id="predBody" class="hidden"></div>
      <div id="topCats" class="hidden"></div>

      <!-- Letter Generation -->
      <div id="letterGeneration" class="mt-4 p-4 bg-blue-50 rounded-lg hidden">
        <h3 class="font-medium mb-3">Generate Letters for Selected Categories</h3>
        <div class="mb-3">
          <label class="block">
            <span class="text-sm">Citizen Full Name</span>
            <input id="citizenName" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="Enter citizen's full name" />
          </label>
        </div>
        <div class="mb-3">
          <label class="block">
            <span class="text-sm">NRIC/FIN</span>
            <input id="citizenNRIC" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="Enter NRIC/FIN" />
          </label>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <button id="btnGenerateLetters" class="btn-primary">Generate Letters for Selected</button>
          <button id="btnSelectAll" class="btn">Select All Categories</button>
        </div>
      </div>

      <!-- Approval Workflow Controls -->
      <div id="approvalControls" class="mt-4 p-4 bg-gray-50 rounded-lg hidden">
        <h3 class="font-medium mb-3">Approval Workflow</h3>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <button id="btnAutoApprove" class="btn-green">Auto Approve (High Confidence)</button>
          <button id="btnManualReview" class="btn-amber">Send for Manual Review</button>
          <button id="btnReject" class="btn-red">Reject Case</button>
        </div>
        <div class="mt-3">
          <label class="block">
            <span class="text-sm">Approval Notes (Optional)</span>
            <textarea id="approvalNotes" rows="2" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="Add notes for approval decision..."></textarea>
          </label>
        </div>
      </div>

      <!-- Generated Letters Container -->
      <div id="lettersWrap" class="mt-6 hidden">
        <h3 class="font-medium mb-3">Generated Letters</h3>
        <div id="lettersContainer" class="space-y-4"></div>
      </div>
    </section>

    <footer class="text-xs text-gray-500 pb-8">
      v0.4 — Single-file tester. No server-side storage. Uses permanent Cloudflare API. Do not paste PII on public links.
    </footer>
  </div>

<script>
/** ---------- Tiny helpers ---------- */
const qs = (id) => document.getElementById(id);
const $ = (sel, el=document) => el.querySelector(sel);
const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

const state = {
  preds: null,
  truthAdd: new Set(),
  checked: new Set(),
  labels: [],           // all label slugs from /labels
  labelsLoaded: false,
  rejections: {},       // {label: reason}
  approvals: {},        // {label: true}
  chatMode: false,      // whether in guided chat mode
  chatData: {},         // collected data from chat
  chatStep: 0,          // current step in chat flow
  chatQuestions: [],    // questions to ask
  chatTrafficAdded: false // whether traffic fines follow-ups are added
};

// Slot values and feature flags
state.slots = {
  transport: {
    traffic_fines: {
      offence_type: '',
      offence_date: '',
      location: '',
      notice_ref: '',
      fine_amount: '',
      demerit_points: '',
      hardship: '',
      request: ''
    }
  }
};
state.flags = {
  APPROVAL_ENABLED: false
};

function parseBool(v, dflt=false) {
  if (v === undefined || v === null || v === '') return dflt;
  const s = String(v).toLowerCase();
  return ['1','true','yes','y','on'].includes(s);
}
function parseNum(v, dflt) {
  const n = Number(v); return Number.isFinite(n) ? n : dflt;
}
const qp = new URL(location.href).searchParams;

/** ---------- Defaults (baked-in) ---------- */
const BASE_DEFAULTS = {
  // Allow optional env.js to override these
  apiBase: (window.API_BASE || (window.ENV && window.ENV.API_BASE)) || 'https://mps-connect-api-987575541268.asia-southeast1.run.app',
  apiKey: (window.API_KEY || (window.ENV && window.ENV.API_KEY)) || 'mps-85-whampoa',
  confidenceThreshold: 0.2,
  maxCategories: 6,
  maxSubCategories: 10
};

// Clear old localhost settings from localStorage if they exist
if (localStorage.getItem('wv.apiBase') === 'http://localhost:8000') {
  localStorage.removeItem('wv.apiBase');
  console.log('Cleared old localhost API setting from localStorage');
}

// Load order: URL params > localStorage > BASE_DEFAULTS
const DEFAULTS = {
  apiBase: qp.get('api') || localStorage.getItem('wv.apiBase') || BASE_DEFAULTS.apiBase,
  apiKey:  qp.get('key') || localStorage.getItem('wv.apiKey')  || BASE_DEFAULTS.apiKey,
  confidenceThreshold: parseNum(qp.get('conf'), parseFloat(localStorage.getItem('wv.confThreshold') ?? BASE_DEFAULTS.confidenceThreshold)),
  maxCategories: parseNum(qp.get('maxCat'), parseInt(localStorage.getItem('wv.maxCategories') ?? BASE_DEFAULTS.maxCategories)),
  maxSubCategories: parseNum(qp.get('maxSub'), parseInt(localStorage.getItem('wv.maxSubCategories') ?? BASE_DEFAULTS.maxSubCategories))
};

if ([...qp.keys()].length) qs('urlNotice').classList.remove('hidden');

function initForm() {
  qs('apiBase').value = DEFAULTS.apiBase;
  qs('apiKey').value = DEFAULTS.apiKey;
  qs('confidenceThreshold').value = DEFAULTS.confidenceThreshold;
  qs('maxCategories').value = DEFAULTS.maxCategories;
  qs('maxSubCategories').value = DEFAULTS.maxSubCategories;
}

// Feature flag: Approval controls
function applyFeatureFlags() {
  const ff = parseBool(qp.get('approval'), parseBool(localStorage.getItem('wv.APPROVAL_ENABLED'), false));
  state.flags.APPROVAL_ENABLED = ff;
  const el = qs('approvalControls');
  if (!el) return;
  if (state.flags.APPROVAL_ENABLED) {
    el.classList.remove('hidden');
  } else {
    el.classList.add('hidden');
  }
}

// Persistence model for letter edits and explainability bundles (in-memory)
const persistence = {
  letters: new Map(), // id -> { content, edits, explainability }
  explainability: new Map(), // id -> { selectedCategories, extractedFacts, confidence }
  
  saveLetter(id, content, edits = {}) {
    this.letters.set(id, { content, edits, timestamp: Date.now() });
  },
  
  saveExplainability(id, selectedCategories, extractedFacts, confidence) {
    this.explainability.set(id, { selectedCategories, extractedFacts, confidence, timestamp: Date.now() });
  },
  
  getLetter(id) {
    return this.letters.get(id);
  },
  
  getExplainability(id) {
    return this.explainability.get(id);
  },
  
  export() {
    return {
      letters: Object.fromEntries(this.letters),
      explainability: Object.fromEntries(this.explainability)
    };
  }
};

function saveSettings() {
  localStorage.setItem('wv.apiBase', qs('apiBase').value.trim());
  localStorage.setItem('wv.apiKey', qs('apiKey').value.trim());
  localStorage.setItem('wv.confThreshold', qs('confidenceThreshold').value);
  localStorage.setItem('wv.maxCategories', qs('maxCategories').value);
  localStorage.setItem('wv.maxSubCategories', qs('maxSubCategories').value);
}

/** ---------- API helpers with auto-normalization and /api fallback ---------- */
function getApiBase() {
  const raw = (qs('apiBase').value || '').trim();
  console.log('API Base raw value:', raw);
  // strip accidental /healthz, /predict, /labels, /api, trailing slash
  const base = raw.replace(/\/(healthz|predict|labels|api)(\/)?$/i, '').replace(/\/$/, '');
  console.log('API Base processed:', base);
  return base;
}
async function apiFetch(path, opts = {}) {
  const base = getApiBase();
  const key = qs('apiKey').value.trim();
  const method = (opts.method || 'GET').toUpperCase();

  const headers = {
    ...(method !== 'GET' ? { 'Content-Type': 'application/json' } : {}),
    ...(key ? { 'X-API-Key': key } : {})
  };

  const doFetch = (p) => fetch(base + p, { ...opts, method, headers, mode: 'cors', credentials: 'omit' });

  let r = await doFetch(path);
  if (r.status === 404 && !path.startsWith('/api/')) {
    r = await doFetch('/api' + path);
  }
  if (r.status === 401) throw new Error('401 Unauthorized – check X-API-Key');
  if (!r.ok) throw new Error('HTTP ' + r.status);
  return r.json();
}

/** ---------- Healthz ---------- */
async function healthz() {
  qs('healthOut').textContent = 'Checking…';
  try {
    const j = await apiFetch('/healthz', { method: 'GET' });
    qs('healthOut').textContent = `OK — labels: ${j.labels}, tops: ${j.tops}`;
  } catch (e) {
    qs('healthOut').textContent = 'Failed: ' + (e?.message || e);
  }
}

/** ---------- Labels (chooser) ---------- */
async function loadLabelsOnce() {
  if (state.labelsLoaded) return;
  const status = qs('labelsStatus');
  status.textContent = 'Loading…';
  try {
    const j = await apiFetch('/labels', { method: 'GET' });
    const arr = Array.isArray(j.labels) ? j.labels : (j.labels?.labels || []);
    state.labels = arr || [];
    state.labelsLoaded = true;
    status.textContent = `${state.labels.length} labels`;
    renderLabelSearchResults();
  } catch (e) {
    status.textContent = 'Failed to load labels';
  }
}
function filterLabels(query) {
  if (!query || query.length < 2) return [];
  const q = query.toLowerCase();
  // match on full slug, top, or child
  return state.labels.filter(l => {
    if (!l) return false;
    const s = String(l).toLowerCase();
    if (s.includes(q)) return true;
    const parts = s.split('/');
    return parts.some(p => p.includes(q));
  }).slice(0, 200); // cap UI list
}
function renderLabelSearchResults() {
  const q = qs('labelSearch').value.trim();
  const target = qs('labelsList');
  target.innerHTML = '';
  if (q.length < 2) {
    target.innerHTML = `<div class="px-3 py-2 text-sm text-gray-500">Type at least 2 characters to search…</div>`;
    return;
  }
  const res = filterLabels(q);
  if (res.length === 0) {
    target.innerHTML = `<div class="px-3 py-2 text-sm text-gray-500">No matches.</div>`;
    return;
  }
  const frag = document.createDocumentFragment();
  res.forEach(lab => {
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between px-3 py-2 bg-white';
    row.innerHTML = `
      <div class="mono text-sm">${lab}</div>
      <div class="flex items-center gap-2">
        <button class="btn-ghost" data-act="add" data-lab="${lab}">Add</button>
      </div>
    `;
    row.querySelector('[data-act=add]').addEventListener('click', () => {
      state.truthAdd.add(lab);
      updateMetrics();
      // subtle flash / confirmation
      row.querySelector('[data-act=add]').textContent = 'Added';
      setTimeout(() => { row.querySelector('[data-act=add]').textContent = 'Add'; }, 800);
    });
    frag.appendChild(row);
  });
  target.appendChild(frag);
}

/** ---------- Guided Chat Mode ---------- */
function toggleChatMode() {
  const singleShot = qs('singleShotMode');
  const guidedChat = qs('guidedChatMode');
  const toggleBtn = qs('toggleMode');
  
  if (state.chatMode) {
    // Switch to single-shot mode
    state.chatMode = false;
    singleShot.classList.remove('hidden');
    guidedChat.classList.add('hidden');
    toggleBtn.textContent = 'Switch to Guided Chat';
    toggleBtn.className = 'bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700';
  } else {
    // Switch to guided chat mode
    state.chatMode = true;
    singleShot.classList.add('hidden');
    guidedChat.classList.remove('hidden');
    toggleBtn.textContent = 'Switch to Single Analysis';
    toggleBtn.className = 'bg-gray-600 text-white px-3 py-1 rounded text-sm hover:bg-gray-700';
    startGuidedChat();
  }
}

/** ---------- Traffic Fines Schema (transport) ---------- */
const TRAFFIC_FINES_SCHEMA = {
  fields: [
    { key: 'offence_type', label: 'Offence Type', required: true, validate: (v) => v && v.length >= 3 },
    { key: 'offence_date', label: 'Offence Date (YYYY-MM-DD)', required: true, validate: (v) => /^\d{4}-\d{2}-\d{2}$/.test(v) },
    { key: 'location', label: 'Location', required: true, validate: (v) => v && v.length >= 3 },
    { key: 'notice_ref', label: 'Notice Number / Reference', required: true, validate: (v) => /[\w-]{4,}/.test(v) },
    { key: 'fine_amount', label: 'Fine Amount (S$)', required: false, validate: (v) => v === '' || /^\d+(?:\.\d{1,2})?$/.test(v) },
    { key: 'demerit_points', label: 'Demerit Points', required: false, validate: (v) => v === '' || /^\d+$/.test(v) },
    { key: 'hardship', label: 'Financial Hardship (summary)', required: true, validate: (v) => v && v.length >= 5 },
    { key: 'request', label: 'Requested Outcome', required: true, validate: (v) => v && v.length >= 5 }
  ]
};

function validateTrafficFines(values) {
  const errors = {};
  let validCount = 0;
  for (const f of TRAFFIC_FINES_SCHEMA.fields) {
    const ok = !!f.validate(String(values[f.key] || ''));
    if (!ok && f.required) errors[f.key] = `${f.label} is required/invalid`;
    if (ok) validCount++;
  }
  const readiness = Math.round((validCount / TRAFFIC_FINES_SCHEMA.fields.length) * 100);
  return { errors, readiness };
}

function renderTrafficFinesSection(catTop) {
  if (catTop !== 'transport') return '';
  const v = state.slots.transport.traffic_fines;
  const { errors, readiness } = validateTrafficFines(v);
  const chip = (key, label) => {
    const ok = !errors[key];
    return `<span class="badge ${ok ? '' : 'bg-red-100'}">${label}${ok ? '' : ' ✕'}</span>`;
  };
  return `
    <div class="mt-3 p-3 rounded border bg-blue-50">
      <div class="flex items-center justify-between mb-2">
        <h6 class="font-medium text-blue-800">Traffic Fines Details</h6>
        <div class="text-xs">Readiness: <span class="font-semibold">${readiness}%</span></div>
      </div>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
        <label class="block text-sm">Offence Type
          <input data-tf key="offence_type" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="e.g., Speeding" value="${v.offence_type || ''}">
        </label>
        <label class="block text-sm">Offence Date (YYYY-MM-DD)
          <input data-tf key="offence_date" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="YYYY-MM-DD" value="${v.offence_date || ''}">
        </label>
        <label class="block text-sm">Location
          <input data-tf key="location" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="Road/Area" value="${v.location || ''}">
        </label>
        <label class="block text-sm">Notice Number / Reference
          <input data-tf key="notice_ref" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="TPxxxx / Ref" value="${v.notice_ref || ''}">
        </label>
        <label class="block text-sm">Fine Amount (S$)
          <input data-tf key="fine_amount" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="e.g., 200.00" value="${v.fine_amount || ''}">
        </label>
        <label class="block text-sm">Demerit Points
          <input data-tf key="demerit_points" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="e.g., 6" value="${v.demerit_points || ''}">
        </label>
        <label class="block text-sm md:col-span-2">Financial Hardship (summary)
          <textarea data-tf key="hardship" rows="2" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="Brief hardship context">${v.hardship || ''}</textarea>
        </label>
        <label class="block text-sm md:col-span-2">Requested Outcome
          <textarea data-tf key="request" rows="2" class="mt-1 w-full rounded-lg border px-3 py-2" placeholder="What are you requesting?">${v.request || ''}</textarea>
        </label>
      </div>
      <div class="mt-2 flex flex-wrap gap-2">
        ${chip('offence_type','Offence')}
        ${chip('offence_date','Date')}
        ${chip('location','Location')}
        ${chip('notice_ref','Notice Ref')}
        ${chip('hardship','Hardship')}
        ${chip('request','Request')}
      </div>
    </div>
  `;
}

document.addEventListener('input', (e) => {
  const t = e.target;
  if (t && t.hasAttribute('data-tf')) {
    const key = t.getAttribute('key');
    if (!key) return;
    state.slots.transport.traffic_fines[key] = t.value;
    // Re-render transport section chips/readiness minimally by updating closest container
    const wrap = t.closest('.mt-3.p-3.rounded.border.bg-blue-50');
    if (wrap) {
      const { errors, readiness } = validateTrafficFines(state.slots.transport.traffic_fines);
      const badges = wrap.querySelectorAll('.badge');
      const map = { offence_type:0, offence_date:1, location:2, notice_ref:3, hardship:4, request:5 };
      const idx = map[key];
      if (typeof idx === 'number' && badges[idx]) {
        const labelText = badges[idx].textContent.replace(' ✕','');
        badges[idx].className = 'badge' + (errors[key] ? ' bg-red-100' : '');
        badges[idx].textContent = labelText + (errors[key] ? ' ✕' : '');
      }
      const rz = wrap.querySelector('span.font-semibold');
      if (rz) rz.textContent = `${Math.round((Object.keys(TRAFFIC_FINES_SCHEMA.fields).length ? validateTrafficFines(state.slots.transport.traffic_fines).readiness : readiness))}%`;
    }
    // Update letter generation state when traffic fines fields change
    updateLetterGenerationState();
  }
});

// LLM-Guided Chat System
let chatSession = {
  sessionId: null,
  language: 'en',
  context: {},
  facts: [],
  agencies: [],
  isComplete: false
};

function startGuidedChat() {
  // Generate unique session ID
  chatSession.sessionId = 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  chatSession.language = 'en';
  chatSession.context = {};
  chatSession.facts = [];
  chatSession.agencies = [];
  chatSession.isComplete = false;
  
  // Clear chat messages
  clearChatMessages();
  
  // Show initial message
  addChatMessage('assistant', "Hi there! I'm MPS Connect, your friendly MP Office assistant. I'm here to help you with whatever government matter you're dealing with. I know these things can be quite stressful, so don't worry - we'll work through this together. What's the main issue you'd like help with today?");
  
  // Enable chat input
  const chatInput = qs('chatInput');
  const sendBtn = qs('btnSendChat');
  if (chatInput && sendBtn) {
    chatInput.disabled = false;
    sendBtn.disabled = false;
    chatInput.focus();
  }
}

async function sendChatMessage() {
  const chatInput = qs('chatInput');
  const message = chatInput.value.trim();
  
  if (!message || chatSession.isComplete) return;
  
  // Add user message to chat
  addChatMessage('user', message);
  
  // Clear input and disable
  chatInput.value = '';
  chatInput.disabled = true;
  const sendBtn = qs('btnSendChat');
  if (sendBtn) sendBtn.disabled = true;
  
  // Show typing indicator
  showTypingIndicator();
  
  try {
    // Call LLM-guided chat API
    const response = await callLLMChatAPI(message);
    
    // Hide typing indicator
    hideTypingIndicator();
    
    if (response.success) {
      // Add assistant response
      addChatMessage('assistant', response.message);
      
      // Update session data
      chatSession.language = response.language;
      chatSession.facts = [...chatSession.facts, ...response.facts_extracted];
      chatSession.agencies = response.suggested_agencies;
      chatSession.isComplete = response.is_complete;
      
      // Show facts and agencies if available
      if (response.facts_extracted.length > 0) {
        showExtractedFacts(response.facts_extracted);
      }
      
      if (response.suggested_agencies.length > 0) {
        showSuggestedAgencies(response.suggested_agencies);
      }
      
      // Optional: quick chips for missing facts if provided
      if (Array.isArray(response.missing_facts) && response.missing_facts.length > 0) {
        showMissingFactChips(response.missing_facts);
      }
      
      // If conversation is complete, show next steps
      if (response.is_complete) {
        showChatCompletion();
      } else {
        // Re-enable input for next message
        chatInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        chatInput.focus();
      }
    } else {
      // Handle error
      addChatMessage('assistant', 'I apologize, but I encountered an error processing your message. Please try again.');
      chatInput.disabled = false;
      if (sendBtn) sendBtn.disabled = false;
      chatInput.focus();
    }
  } catch (error) {
    console.error('Chat API error:', error);
    hideTypingIndicator();
    addChatMessage('assistant', 'I apologize, but I encountered an error. Please try again.');
    chatInput.disabled = false;
    if (sendBtn) sendBtn.disabled = false;
    chatInput.focus();
  }
}

async function callLLMChatAPI(message) {
  const isFirstMessage = chatSession.facts.length === 0;
  const endpoint = isFirstMessage ? '/api/chat/start' : '/api/chat/continue';
  
  const response = await fetch(`${window.API_BASE}${endpoint}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-API-Key': window.API_KEY
    },
    body: JSON.stringify({
      session_id: chatSession.sessionId,
      message: message,
      language: chatSession.language,
      context: chatSession.context
    })
  });
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  return await response.json();
}

function showExtractedFacts(facts) {
  const factsContainer = qs('chatMessages');
  if (!factsContainer) return;
  
  const factsDiv = document.createElement('div');
  factsDiv.className = 'mt-3 p-3 bg-blue-50 rounded-lg border-l-4 border-blue-400';
  factsDiv.innerHTML = `
    <div class="text-sm font-medium text-blue-800 mb-2">Key Information I've Gathered:</div>
    <div class="space-y-1">
      ${facts.map(fact => `
        <div class="text-sm text-blue-700">
          <span class="font-medium">${fact.type}:</span> ${fact.content}
        </div>
      `).join('')}
    </div>
  `;
  
  factsContainer.appendChild(factsDiv);
  factsContainer.scrollTop = factsContainer.scrollHeight;
}

// Optional quick chips: call with an array of strings describing missing items
function showMissingFactChips(missingFacts) {
  if (!Array.isArray(missingFacts) || missingFacts.length === 0) return;
  const chatMessages = qs('chatMessages');
  if (!chatMessages) return;
  
  const chips = document.createElement('div');
  chips.className = 'mt-2 p-2 bg-amber-50 rounded border border-amber-200';
  chips.innerHTML = `
    <div class="text-xs text-amber-700 mb-1">Missing info I still need (tap to fill):</div>
    <div class="flex flex-wrap gap-2">
      ${missingFacts.map(m => `<button class="px-2 py-1 text-xs bg-white border rounded hover:bg-amber-100" data-missing="${m}">${m}</button>`).join('')}
    </div>
  `;
  chatMessages.appendChild(chips);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  chips.querySelectorAll('button[data-missing]').forEach(btn => {
    btn.addEventListener('click', () => {
      const chatInput = qs('chatInput');
      if (!chatInput) return;
      // Prefill a polite prompt requesting the missing fact
      const item = btn.getAttribute('data-missing');
      chatInput.value = `Regarding ${item}, it is: `;
      chatInput.focus();
    });
  });
}

function showSuggestedAgencies(agencies) {
  const agenciesContainer = qs('chatMessages');
  if (!agenciesContainer) return;
  
  const agenciesDiv = document.createElement('div');
  agenciesDiv.className = 'mt-3 p-3 bg-green-50 rounded-lg border-l-4 border-green-400';
  agenciesDiv.innerHTML = `
    <div class="text-sm font-medium text-green-800 mb-2">Suggested Government Agencies:</div>
    <div class="space-y-2">
      ${agencies.map(agency => `
        <div class="text-sm text-green-700">
          <div class="font-medium">${agency.agency}</div>
          <div class="text-xs text-green-600">${agency.reason}</div>
          <div class="text-xs text-gray-600">Priority: ${agency.priority}</div>
        </div>
      `).join('')}
    </div>
  `;
  
  agenciesContainer.appendChild(agenciesDiv);
  agenciesContainer.scrollTop = agenciesContainer.scrollHeight;
}

function showChatCompletion() {
  const chatContainer = qs('chatContainer');
  if (!chatContainer) return;
  
  const completionDiv = document.createElement('div');
  completionDiv.className = 'mt-4 p-4 bg-green-100 rounded-lg border border-green-300';
  completionDiv.innerHTML = `
    <div class="text-green-800 font-medium mb-2">Great! I have enough information to help you.</div>
    <div class="text-sm text-green-700 mb-3">Based on our conversation, I can now generate a professional letter for your case.</div>
    <div class="flex gap-2">
      <button id="btnReviewFacts" class="px-3 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
        Review Information
      </button>
      <button id="btnGenerateLetter" class="px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700">
        Generate Letter
      </button>
    </div>
  `;
  
  chatContainer.appendChild(completionDiv);
  
  // Add event listeners
  const reviewBtn = completionDiv.querySelector('#btnReviewFacts');
  const generateBtn = completionDiv.querySelector('#btnGenerateLetter');
  
  if (reviewBtn) {
    reviewBtn.addEventListener('click', showFactsChecklist);
  }
  
  if (generateBtn) {
    generateBtn.addEventListener('click', generateLetterFromChat);
  }
}

function showFactsChecklist() {
  // This will show the "What I understood" checklist
  const checklistDiv = document.createElement('div');
  checklistDiv.className = 'mt-4 p-4 bg-yellow-50 rounded-lg border border-yellow-300';
  checklistDiv.innerHTML = `
    <div class="text-yellow-800 font-medium mb-3">What I Understood - Please Review:</div>
    <div class="space-y-2" id="factsChecklist">
      ${chatSession.facts.map((fact, index) => `
        <div class="flex items-center gap-2">
          <input type="checkbox" id="fact_${index}" checked class="rounded">
          <label for="fact_${index}" class="text-sm text-yellow-700">${fact.content}</label>
          <button class="text-xs text-blue-600 hover:text-blue-800" onclick="editFact(${index})">Edit</button>
        </div>
      `).join('')}
    </div>
    <div class="mt-3 flex gap-2">
      <button id="btnConfirmFacts" class="px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700">
        Confirm & Generate Letter
      </button>
      <button id="btnCancelFacts" class="px-3 py-2 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
        Cancel
      </button>
    </div>
  `;
  
  const chatContainer = qs('chatContainer');
  if (chatContainer) {
    chatContainer.appendChild(checklistDiv);
  }
  
  // Add event listeners
  const confirmBtn = checklistDiv.querySelector('#btnConfirmFacts');
  const cancelBtn = checklistDiv.querySelector('#btnCancelFacts');
  
  if (confirmBtn) {
    confirmBtn.addEventListener('click', generateLetterFromChat);
  }
  
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => checklistDiv.remove());
  }
}

async function generateLetterFromChat() {
  try {
    const response = await fetch(`${window.API_BASE}/api/chat/generate-letter`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': window.API_KEY
      },
      body: JSON.stringify({
        session_id: chatSession.sessionId,
        language: chatSession.language,
        context: chatSession.context
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    
    if (result.success) {
      // Show generated letter
      showGeneratedLetter(result.data);
  } else {
      addChatMessage('assistant', 'I apologize, but I encountered an error generating your letter. Please try again.');
    }
  } catch (error) {
    console.error('Letter generation error:', error);
    addChatMessage('assistant', 'I apologize, but I encountered an error generating your letter. Please try again.');
  }
}

function showGeneratedLetter(letterData) {
  const letterDiv = document.createElement('div');
  letterDiv.className = 'mt-4 p-4 bg-white rounded-lg border border-gray-300';
  letterDiv.innerHTML = `
    <div class="text-gray-800 font-medium mb-3">Generated Letter:</div>
    <div class="text-sm text-gray-600 mb-2">
      <strong>Subject:</strong> ${letterData.subject}
    </div>
    <div class="text-sm text-gray-700 whitespace-pre-wrap">${letterData.content}</div>
    <div class="mt-3 flex gap-2">
      <button id="btnCopyLetter" class="px-3 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
        Copy Letter
      </button>
      <button id="btnDownloadLetter" class="px-3 py-2 bg-green-600 text-white rounded text-sm hover:bg-green-700">
        Download Letter
      </button>
    </div>
  `;
  
  const chatContainer = qs('chatContainer');
  if (chatContainer) {
    chatContainer.appendChild(letterDiv);
  }
  
  // Add event listeners
  const copyBtn = letterDiv.querySelector('#btnCopyLetter');
  const downloadBtn = letterDiv.querySelector('#btnDownloadLetter');
  
  if (copyBtn) {
    copyBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(letterData.content);
      copyBtn.textContent = 'Copied!';
      setTimeout(() => copyBtn.textContent = 'Copy Letter', 2000);
    });
  }
  
  if (downloadBtn) {
    downloadBtn.addEventListener('click', () => {
      const blob = new Blob([letterData.content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `MP_Letter_${new Date().toISOString().split('T')[0]}.txt`;
      a.click();
      URL.revokeObjectURL(url);
    });
  }
}

function updateChatProgress() {
  const progressDiv = qs('chatProgress');
  const progressText = qs('progressText');
  const progressBar = qs('progressBar');
  
  if (!progressDiv || !progressText || !progressBar) return;
  
  const totalQuestions = state.chatQuestions.length;
  const currentStep = state.chatStep + 1;
  const percentage = Math.round((currentStep / totalQuestions) * 100);
  
  progressDiv.classList.remove('hidden');
  progressText.textContent = `${currentStep} / ${totalQuestions}`;
  progressBar.style.width = `${percentage}%`;
}

function addChatMessage(sender, message) {
  const chatMessages = qs('chatMessages');
  const messageDiv = document.createElement('div');
  messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
  
  const bubbleClass = sender === 'user' 
    ? 'bg-blue-600 text-white rounded-lg px-3 py-2 max-w-xs'
    : 'bg-white border rounded-lg px-3 py-2 max-w-xs';
    
  messageDiv.innerHTML = `
    <div class="${bubbleClass}">
      <div class="text-sm">${message}</div>
    </div>
  `;
  
  chatMessages.appendChild(messageDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function showTypingIndicator() {
  const typingIndicator = qs('typingIndicator');
  if (typingIndicator) {
    typingIndicator.classList.remove('hidden');
  }
}

function hideTypingIndicator() {
  const typingIndicator = qs('typingIndicator');
  if (typingIndicator) {
    typingIndicator.classList.add('hidden');
  }
}

function showQuickActions(question) {
  const quickActions = qs('quickActions');
  const quickActionButtons = qs('quickActionButtons');
  
  if (!quickActions || !quickActionButtons) return;
  
  // Clear existing buttons
  quickActionButtons.innerHTML = '';
  
  // Generate quick actions based on question type
  if (question.type === 'yesno') {
    const yesBtn = createQuickActionButton('Yes', () => {
      qs('chatInput').value = 'yes';
      sendChatMessage();
    });
    const noBtn = createQuickActionButton('No', () => {
      qs('chatInput').value = 'no';
      sendChatMessage();
    });
    quickActionButtons.appendChild(yesBtn);
    quickActionButtons.appendChild(noBtn);
  } else if (question.field === 'agency') {
    const agencies = ['Traffic Police', 'HDB', 'IRAS', 'MOM', 'MSF', 'SP Group'];
    agencies.forEach(agency => {
      const btn = createQuickActionButton(agency, () => {
        qs('chatInput').value = agency;
        sendChatMessage();
      });
      quickActionButtons.appendChild(btn);
    });
  } else if (question.field === 'urgency') {
    const urgentBtn = createQuickActionButton('Yes, it\'s urgent', () => {
      qs('chatInput').value = 'yes, it\'s urgent';
      sendChatMessage();
    });
    const notUrgentBtn = createQuickActionButton('No, not urgent', () => {
      qs('chatInput').value = 'no, not urgent';
      sendChatMessage();
    });
    quickActionButtons.appendChild(urgentBtn);
    quickActionButtons.appendChild(notUrgentBtn);
  } else if (question.field === 'financial_hardship') {
    const yesBtn = createQuickActionButton('Yes, I\'m struggling', () => {
      qs('chatInput').value = 'yes, I\'m having financial difficulties';
      sendChatMessage();
    });
    const noBtn = createQuickActionButton('No, I\'m okay', () => {
      qs('chatInput').value = 'no, I\'m financially stable';
      sendChatMessage();
    });
    quickActionButtons.appendChild(yesBtn);
    quickActionButtons.appendChild(noBtn);
  }
  
  quickActions.classList.remove('hidden');
}

function hideQuickActions() {
  const quickActions = qs('quickActions');
  if (quickActions) {
    quickActions.classList.add('hidden');
  }
}

function createQuickActionButton(text, onClick) {
  const button = document.createElement('button');
  button.className = 'px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded-full transition-colors';
  button.textContent = text;
  button.addEventListener('click', onClick);
  return button;
}

function updateCharCount() {
  const chatInput = qs('chatInput');
  const charCount = qs('charCount');
  if (!chatInput || !charCount) return;
  
  const length = chatInput.value.length;
  const maxLength = 500;
  charCount.textContent = `${length}/${maxLength}`;
  
  if (length > maxLength * 0.9) {
    charCount.className = 'absolute bottom-1 right-2 text-xs text-red-500';
  } else if (length > maxLength * 0.7) {
    charCount.className = 'absolute bottom-1 right-2 text-xs text-amber-500';
  } else {
    charCount.className = 'absolute bottom-1 right-2 text-xs text-gray-400';
  }
}

function hideCharCount() {
  const charCount = qs('charCount');
  if (charCount) {
    charCount.classList.add('hidden');
  }
}

// Old sendChatMessage function removed - now using LLM-guided version above

// Old completeGuidedChat function removed - now using LLM-guided completion

// Old showSummaryConfirmation function removed - now using LLM-guided facts checklist

// Old generateSummaryData function removed - now using LLM-guided facts extraction

// Old proceedWithLetterGeneration function removed - now using LLM-guided letter generation

// Old chat functions removed - now using LLM-guided system

function clearChatMessages() {
  qs('chatMessages').innerHTML = '';
}

// Old updateChatContext function removed - now using LLM-guided context management

// Old analyzeSentiment function removed - now using LLM-guided sentiment analysis

// Old extractKeyConcerns function removed - now using LLM-guided concern extraction

// Old chat helper functions removed - now using LLM-guided system

/** ---------- Predict & render ---------- */
function renderProvider(p) {
  if (!p) return '<span class="text-gray-400">—</span>';
  const name = p.provider || 'Provider';
  const ch = p.channel ? ` · <a class="text-blue-600 underline" href="${p.channel}" target="_blank" rel="noreferrer">link</a>` : '';
  return `<span class="font-medium">${name}</span><span class="text-gray-500"> (${p.type || '—'})</span>${ch}`;
}

function renderPreds(resp) {
  console.log('renderPreds called with:', resp);
  console.log('Full response structure:', JSON.stringify(resp, null, 2));
  const p = resp?.predictions?.[0];
  console.log('Prediction object:', p);
  state.preds = p || null;
  
  if (!p) {
    console.log('No prediction data found');
    return;
  }

  const topCats = p?.top_categories || [];
  const labels = p.labels || [];
  const scores = p.scores || {};

  const subCategoryList = qs('subCategoryList');
  console.log('subCategoryList element:', subCategoryList);
  if (!subCategoryList) {
    console.error('subCategoryList element not found!');
    return;
  }
  const htmlContent = `
    <div class="mb-4 p-4 bg-blue-50 rounded-lg border">
      <h4 class="font-semibold text-lg text-blue-800 mb-2">AI Analysis Results</h4>
      <p class="text-sm text-blue-600">${labels.length} labels found across ${topCats.length} main categories</p>
      <p class="text-sm text-gray-600 mt-2">Select relevant sub-categories below, then generate letters for selected categories.</p>
    </div>
    <div id="letterGenerationControls" class="mb-4 p-4 bg-green-50 rounded-lg border border-green-200 hidden">
      <h5 class="font-semibold text-green-800 mb-2">Letter Generation Ready</h5>
      <p class="text-sm text-green-600 mb-3">Sub-categories selected. You can now generate letters for the selected categories.</p>
      <button onclick="generateAllLetters()" class="bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700">
        Generate All Selected Letters
      </button>
    </div>
    ${topCats.map(cat => `
      <div class="mb-4 p-4 rounded-lg border bg-white">
        <div class="flex items-center justify-between mb-3">
          <h5 class="font-semibold text-lg">${cat.top.replace('_', ' ').toUpperCase()}</h5>
          <div class="text-right">
            <div class="text-lg font-bold text-blue-600">${(window.STAFF_MODE ? Number(cat.score).toFixed(3) : '—')}</div>
            <div class="text-xs text-gray-500">${(window.STAFF_MODE ? 'Confidence' : '')}</div>
          </div>
        </div>
        <div class="space-y-2">
          ${labels.filter(label => label.startsWith(cat.top + '/')).map(label => {
            const [mainCategory, subCategory] = label.split('/');
            const confidence = scores[label] || 0;
                         return `
               <div class="flex items-center justify-between p-3 bg-gray-50 rounded border">
                 <div class="flex items-center space-x-3">
                   <input type="checkbox" class="rounded" data-label="${label}" data-category="${cat.top}" onchange="updateLetterGenerationState()">
                   <div>
                     <div class="font-medium text-sm">${subCategory.replace('_', ' ')}</div>
                   </div>
                 </div>
                 <div class="text-right">
                   <div class="text-sm font-medium">${(window.STAFF_MODE ? Number(confidence).toFixed(3) : '—')}</div>
                 </div>
               </div>
             `;
          }).join('')}
        </div>
        ${renderTrafficFinesSection(cat.top)}
        <div class="mt-3 pt-3 border-t">
          <button onclick="checkAndGenerateLetter('${cat.top}')" class="w-full bg-gray-400 text-white py-2 px-4 rounded-lg" disabled>
            Select sub-categories first to generate letter
          </button>
        </div>
      </div>
    `).join('')}
  `;
  
  console.log('Setting HTML content, length:', htmlContent.length);
  subCategoryList.innerHTML = htmlContent;
  console.log('HTML set successfully');
  console.log('subCategoryList after setting:', subCategoryList ? subCategoryList.innerHTML.substring(0, 200) + '...' : 'null');
}

// Check if any sub-categories are selected and enable/disable letter generation
function updateLetterGenerationState() {
  const allCheckboxes = document.querySelectorAll('input[type="checkbox"][data-category]');
  const selectedCheckboxes = document.querySelectorAll('input[type="checkbox"][data-category]:checked');
  const letterControls = qs('letterGenerationControls');
  
  if (selectedCheckboxes.length > 0) {
    letterControls.classList.remove('hidden');
    
    // Enable individual category buttons that have selections
    const categorySelections = {};
    selectedCheckboxes.forEach(checkbox => {
      const category = checkbox.dataset.category;
      categorySelections[category] = (categorySelections[category] || 0) + 1;
    });
    
    Object.keys(categorySelections).forEach(category => {
      const button = document.querySelector(`button[onclick*="${category}"]`);
      if (button) {
        // Check schema readiness for transport/traffic fines
        let isReady = true;
        if (category === 'transport') {
          const selectedLabels = Array.from(document.querySelectorAll(`input[data-category="${category}"]:checked`))
            .map(input => input.dataset.label);
          if (selectedLabels.some(l => /transport\/traffic_fines_appeals/.test(l))) {
            const { readiness } = validateTrafficFines(state.slots.transport.traffic_fines);
            isReady = readiness >= 80; // Require 80% readiness for traffic fines
          }
        }
        
        button.disabled = !isReady;
        if (isReady) {
          button.className = 'w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700';
          button.textContent = `Generate Letter for ${category.replace('_', ' ').toUpperCase()} (${categorySelections[category]} selected)`;
        } else {
          button.className = 'w-full bg-amber-500 text-white py-2 px-4 rounded-lg';
          button.textContent = `Complete required fields first (${category.replace('_', ' ').toUpperCase()})`;
        }
      }
    });
  } else {
    letterControls.classList.add('hidden');
    
    // Disable all category buttons
    const buttons = document.querySelectorAll('button[onclick*="checkAndGenerateLetter"]');
    buttons.forEach(button => {
      button.disabled = true;
      button.className = 'w-full bg-gray-400 text-white py-2 px-4 rounded-lg';
      button.textContent = 'Select sub-categories first to generate letter';
    });
  }
}

// Check and generate letter for a specific category
async function checkAndGenerateLetter(category) {
  const selectedSubs = Array.from(document.querySelectorAll(`input[data-category="${category}"]:checked`));
  if (selectedSubs.length === 0) {
    alert('Please select at least one sub-category for letter generation.');
    return;
  }
  
  const selectedLabels = selectedSubs.map(input => input.dataset.label);
  const caseText = qs('caseText').value.trim();
  
  // Check required fields for this category
  const missingFields = checkRequiredFields(category, selectedLabels, caseText);
  if (missingFields.length > 0) {
    const missingList = missingFields.join('\n• ');
    alert(`Missing required information for ${category.replace('_', ' ').toUpperCase()}:\n\n• ${missingList}\n\nPlease ensure all required details are provided before generating the letter.`);
    return;
  }
  
  // Generate letter content (now async)
  const letterContent = await generateLetterContent(category, selectedLabels, caseText);
  
  // Display letter in a modal or new section
  displayLetter(category, letterContent, selectedLabels);
}

// Check required fields for each category
function checkRequiredFields(category, selectedLabels, caseText) {
  const requiredFields = {
    'transport': {
      'traffic_fines_appeals': ['offence date', 'notice number', 'reasons for appeal', 'financial hardship evidence'],
      'road_tax': ['vehicle details', 'payment status', 'reasons for delay'],
      'driver_licence': ['licence type', 'issue date', 'reasons for assistance']
    },
    'social_support': {
      'comcare_short_mid_term': ['household income', 'family size', 'expenses breakdown', 'employment status'],
      'childcare_subsidies': ['child age', 'childcare arrangement', 'household income'],
      'family_violence_protection': ['incident details', 'safety concerns', 'support needed']
    },
    'housing': {
      'hdb_loan_arrears': ['flat details', 'loan amount', 'arrears period', 'payment plan request'],
      'town_council_scc_arrears': ['flat address', 'arrears amount', 'reasons for delay'],
      'enhanced_housing_grant_ehg': ['household income', 'flat type', 'purchase details']
    },
    'tax_finance': {
      'gst_voucher': ['household income', 'family size', 'residential status'],
      'payment_plan_arrangement': ['outstanding amount', 'reasons for difficulty', 'proposed payment terms'],
      'noa_objections_appeals': ['assessment year', 'objection grounds', 'supporting documents']
    },
    'employment': {
      'fair_consideration_framework': ['job details', 'application status', 'discrimination concerns'],
      'workfare_income_supplement': ['employment status', 'income level', 'age requirements'],
      'employment_rights_tadm': ['employment details', 'rights violation', 'evidence']
    },
    'utilities_comms': {
      'electricity_spgroup': ['account details', 'arrears amount', 'payment difficulties'],
      'telecom_bills_singtel': ['service type', 'outstanding amount', 'payment plan request'],
      'gas_city_energy': ['account details', 'usage pattern', 'payment issues']
    }
  };
  
  const missing = [];
  // Schema-driven check for traffic fines when selected
  if (category === 'transport' && selectedLabels.some(l => /transport\/traffic_fines_appeals/.test(l))) {
    const vals = state.slots.transport.traffic_fines || {};
    const { errors } = validateTrafficFines(vals);
    for (const k of Object.keys(errors)) {
      missing.push(errors[k]);
    }
    return missing;
  }
  const categoryFields = requiredFields[category] || {};
  
  selectedLabels.forEach(label => {
    const [mainCat, subCat] = label.split('/');
    const fields = categoryFields[subCat] || [];
    
    fields.forEach(field => {
      if (!isFieldPresent(caseText, field)) {
        missing.push(`${field} (for ${subCat.replace('_', ' ')})`);
      }
    });
  });
  
  return missing;
}

// Check if a required field is present in the case text
function isFieldPresent(caseText, field) {
  const patterns = {
    'offence date': /(?:date|on|when).*?(?:offence|violation|fine)/gi,
    'notice number': /(?:notice|reference|number|no\.).*?[\d\w-]+/gi,
    'reasons for appeal': /(?:reason|because|due to|explanation)/gi,
    'financial hardship evidence': /(?:financial|money|pay|afford|struggling|hardship|bills|debt|unemployed)/gi,
    'vehicle details': /(?:vehicle|car|motor|plate|registration)/gi,
    'payment status': /(?:payment|paid|unpaid|arrears|outstanding)/gi,
    'household income': /(?:income|salary|wage|earn|monthly|annual)/gi,
    'family size': /(?:family|children|kids|household|dependents)/gi,
    'expenses breakdown': /(?:expenses|bills|costs|spending|outgoings)/gi,
    'employment status': /(?:employed|job|work|unemployed|retired|student)/gi,
    'flat details': /(?:flat|unit|block|address|hdb|housing)/gi,
    'loan amount': /(?:loan|amount|\$|dollar)/gi,
    'arrears period': /(?:arrears|outstanding|overdue|months|weeks)/gi,
    'arrears amount': /(?:arrears|outstanding|amount|\$|dollar)/gi,
    'reasons for delay': /(?:reason|because|due to|explanation|delay)/gi,
    'flat address': /(?:address|block|unit|flat|street)/gi,
    'child age': /(?:age|year|old|child|kid)/gi,
    'childcare arrangement': /(?:childcare|care|nursery|kindergarten|school)/gi,
    'incident details': /(?:incident|happened|occurred|situation|event)/gi,
    'safety concerns': /(?:safety|safe|danger|threat|concern)/gi,
    'support needed': /(?:support|help|assistance|protection|shelter)/gi,
    'residential status': /(?:citizen|pr|resident|singaporean|permanent)/gi,
    'outstanding amount': /(?:outstanding|amount|\$|dollar|balance)/gi,
    'reasons for difficulty': /(?:reason|because|due to|difficulty|hardship)/gi,
    'proposed payment terms': /(?:payment|installment|monthly|weekly|terms)/gi,
    'assessment year': /(?:year|assessment|tax|iras)/gi,
    'objection grounds': /(?:objection|dispute|disagree|grounds|reason)/gi,
    'supporting documents': /(?:document|evidence|proof|support|attachment)/gi,
    'job details': /(?:job|position|work|employment|company)/gi,
    'application status': /(?:application|applied|status|response|reply)/gi,
    'discrimination concerns': /(?:discrimination|unfair|bias|prejudice|treat)/gi,
    'income level': /(?:income|salary|wage|earn|low|high)/gi,
    'age requirements': /(?:age|year|old|requirement|eligible)/gi,
    'employment details': /(?:employment|job|work|company|employer)/gi,
    'rights violation': /(?:rights|violation|breach|unfair|illegal)/gi,
    'evidence': /(?:evidence|proof|document|record|support)/gi,
    'account details': /(?:account|number|reference|id)/gi,
    'arrears amount': /(?:arrears|outstanding|amount|\$|dollar)/gi,
    'payment difficulties': /(?:payment|difficulty|problem|issue|struggle)/gi,
    'service type': /(?:service|mobile|broadband|internet|phone)/gi,
    'payment plan request': /(?:payment|plan|installment|arrangement|terms)/gi,
    'usage pattern': /(?:usage|consumption|pattern|habit|regular)/gi,
    'payment issues': /(?:payment|issue|problem|difficulty|struggle)/gi
  };
  
  const pattern = patterns[field.toLowerCase()];
  return pattern ? pattern.test(caseText) : false;
}

// Generate letter content using Gemini API
async function generateLetterContent(category, selectedLabels, caseText) {
  try {
    // Prepare case data for Gemini
    const caseData = {
      category: category,
      subCategories: selectedLabels,
      caseText: caseText,
      citizenName: qs('citizenName')?.value || '',
      citizenNRIC: qs('citizenNRIC')?.value || '',
      timestamp: new Date().toISOString()
    };

    // Call Gemini API for letter generation
    const response = await fetch(`${getApiBase()}/api/gemini/generate-letter-final`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': qs('apiKey').value.trim()
      },
      body: JSON.stringify({
        case_data: caseData
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success && result.data) {
      return result.data.content;
    } else {
      throw new Error(result.error || 'Letter generation failed');
    }
  } catch (error) {
    console.error('Error generating letter with Gemini:', error);
    // Fallback to simple letter generation
    return generateSimpleLetter(category, selectedLabels, caseText);
  }
}

// Simple fallback letter generation
function generateSimpleLetter(category, selectedLabels, caseText) {
  const citizenName = qs('citizenName')?.value || '[Citizen Name]';
  const citizenNRIC = qs('citizenNRIC')?.value || '[NRIC]';
  
  return `Subject: Request for Assistance - ${category.replace('_', ' ').toUpperCase()}

Dear Sir/Madam,

I am writing on behalf of my constituent, ${citizenName} (NRIC: ${citizenNRIC}), regarding the following matter:

CASE DETAILS:
${caseText}

REQUEST:
I would like to request your kind consideration and assistance with this matter. My constituent is facing challenging circumstances and would greatly appreciate any support or guidance you can provide.

I understand the importance of following proper procedures and my constituent is committed to resolving this matter responsibly.

Thank you for your time and consideration.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

// Extract key facts from case text and paraphrase them
function extractKeyFacts(caseText, selectedLabels) {
  const facts = [];
  
  // Basic fact extraction patterns
  const patterns = {
    financial_hardship: /(?:financial|money|pay|afford|struggling|hardship|bills|debt|unemployed|jobless)/gi,
    family_situation: /(?:kids|children|family|wife|husband|sick|ill|disabled)/gi,
    specific_amounts: /(?:fine|penalty|fee|cost|charge|bill).*?\$?[\d,]+/gi,
    time_references: /(?:recently|lately|last|this|next|month|year|week|day)/gi,
    urgency: /(?:urgent|immediate|asap|quickly|soon|emergency)/gi
  };
  
  // Check for financial hardship
  if (patterns.financial_hardship.test(caseText)) {
    facts.push("The resident is experiencing financial difficulties and requires assistance");
  }
  
  // Check for family situation
  if (patterns.family_situation.test(caseText)) {
    facts.push("The resident has family responsibilities that impact their situation");
  }
  
  // Extract specific amounts mentioned
  const amounts = caseText.match(patterns.specific_amounts);
  if (amounts && amounts.length > 0) {
    facts.push(`Specific amounts involved: ${amounts.slice(0, 3).join(', ')}`);
  }
  
  // Check for urgency
  if (patterns.urgency.test(caseText)) {
    facts.push("The matter requires timely attention");
  }
  
  // Add category-specific facts based on selected labels
  selectedLabels.forEach(label => {
    const [mainCat, subCat] = label.split('/');
    const subCategoryName = subCat.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    if (mainCat === 'transport' && subCat.includes('traffic_fines')) {
      facts.push("Traffic violation matter requiring appeal consideration");
    } else if (mainCat === 'social_support') {
      facts.push(`${subCategoryName} assistance is being sought`);
    } else if (mainCat === 'housing') {
      facts.push(`${subCategoryName} matter requiring attention`);
    } else if (mainCat === 'tax_finance') {
      facts.push(`${subCategoryName} issue needs resolution`);
    } else if (mainCat === 'employment') {
      facts.push(`${subCategoryName} matter requires guidance`);
    } else if (mainCat === 'utilities_comms') {
      facts.push(`${subCategoryName} issue needs assistance`);
    }
  });
  
  // If no specific facts extracted, provide generic statement
  if (facts.length === 0) {
    facts.push("The resident requires assistance with government services and procedures");
  }
  
  return facts;
}

// Enhanced Letter Generation System
const letterTemplates = {
  transport: {
    traffic_fines: {
      generate: (context, slots, caseText) => generateTrafficFinesLetter(context, slots, caseText),
      tone: 'professional',
      urgency: true,
      personalization: true
    }
  },
  housing: {
    hdb_appeals: {
      generate: (context, slots, caseText) => generateHDBAppealLetter(context, slots, caseText),
      tone: 'formal',
      urgency: false,
      personalization: true
    }
  },
  social_support: {
    comcare_applications: {
      generate: (context, slots, caseText) => generateComCareLetter(context, slots, caseText),
      tone: 'compassionate',
      urgency: true,
      personalization: true
    }
  }
};

function generateEnhancedLetter(category, subCategory, caseText, selectedLabels) {
  const context = state.chatContext || {};
  const slots = state.slots || {};
  
  // Get template for this category and subcategory
  const template = letterTemplates[category]?.[subCategory];
  
  if (template) {
    return template.generate(context, slots, caseText);
  }
  
  // Fallback to original letter generation
  return generateOriginalLetter(category, caseText, selectedLabels);
}

function generateTrafficFinesLetter(context, slots, caseText) {
  const trafficData = slots.transport?.traffic_fines || {};
  const urgency = context.urgency || false;
  const stressLevel = context.stressLevel || 'low';
  const emotionalTone = context.emotionalTone || 'neutral';
  
  // Extract key information from case text
  const facts = extractEnhancedFacts(caseText);
  
  // Generate subject line
  const subjectLine = generateSubjectLine('transport', facts, slots);
  
  // Determine letter tone based on context
  let openingTone = "I am writing to appeal";
  if (emotionalTone === 'stressed' || stressLevel === 'high') {
    openingTone = "I am writing to urgently appeal";
  } else if (emotionalTone === 'positive') {
    openingTone = "I am writing to respectfully appeal";
  }
  
  // Build personalized content
  let personalCircumstances = "";
  if (context.keyConcerns?.includes('financial_difficulties')) {
    personalCircumstances += "\n\nI am currently experiencing financial difficulties and would greatly appreciate any consideration for a reduction in the fine amount or a payment plan arrangement.";
  }
  
  if (context.keyConcerns?.includes('family_issues')) {
    personalCircumstances += "\n\nThis matter is particularly concerning as it affects my family situation, and I am committed to resolving this matter responsibly.";
  }
  
  // Generate professional letter with paraphrased content
  let letter = `Subject: ${subjectLine}

Dear Sir/Madam,

${openingTone} the traffic fine issued to my constituent. I have reviewed the case details and would like to present the following information for your consideration.

CASE REFERENCE:
- Notice Number: ${trafficData.notice_number || 'To be provided'}
- Offence Type: ${trafficData.offence_type || 'To be confirmed'}
- Offence Date: ${trafficData.offence_date || 'To be confirmed'}
- Location: ${trafficData.location || 'To be confirmed'}
- Fine Amount: $${trafficData.fine_amount || 'To be confirmed'}
- Demerit Points: ${trafficData.demerit_points || 'To be confirmed'}

FINANCIAL HARDSHIP SUMMARY:
${trafficData.financial_hardship || 'Constituent experiencing financial difficulties that warrant compassionate consideration.'}

REQUESTED OUTCOME:
${trafficData.requested_outcome || 'Waiver of offence on compassionate grounds, including waiver of composite fine.'}

CONSTITUENT'S SITUATION:
${facts.circumstances || 'My constituent has provided details regarding the circumstances surrounding this matter.'}${personalCircumstances}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

REQUEST FOR CONSIDERATION:
${trafficData.request || 'I respectfully request your consideration for leniency in this matter, taking into account the circumstances outlined above.'}

My constituent is committed to being a responsible road user and would appreciate your kind consideration of this appeal. I am available to provide any additional information or documentation that may be required.

Thank you for your time and consideration.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;

  return letter;
}

function generateHDBAppealLetter(context, slots, caseText) {
  const facts = extractEnhancedFacts(caseText);
  const urgency = context.urgency || false;
  const emotionalTone = context.emotionalTone || 'neutral';
  const subjectLine = generateSubjectLine('housing', facts, slots);
  
  let openingTone = "I am writing to appeal";
  if (urgency) {
    openingTone = "I am writing to urgently appeal";
  }
  
  let personalCircumstances = "";
  if (context.keyConcerns?.includes('family_issues')) {
    personalCircumstances += "\n\nThis matter significantly impacts my family's housing situation, and I would greatly appreciate your consideration of our circumstances.";
  }
  
  if (context.keyConcerns?.includes('financial_difficulties')) {
    personalCircumstances += "\n\nGiven my current financial situation, I would be grateful for any flexibility in the terms or timeline for this matter.";
  }
  
  return `Subject: ${subjectLine}

Dear HDB Officer,

${openingTone} the decision regarding my constituent's housing application/appeal.

CONSTITUENT'S CASE:
${facts.details || 'My constituent has provided detailed information regarding their housing situation.'}

SITUATION OVERVIEW:
${facts.circumstances || 'My constituent would like to provide additional context regarding their circumstances.'}${personalCircumstances}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

REQUEST FOR RECONSIDERATION:
I respectfully request your reconsideration of this matter and would appreciate any guidance on how my constituent should proceed.

My constituent is committed to fulfilling all requirements and would be grateful for your assistance in resolving this matter.

Thank you for your time and consideration.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function generateComCareLetter(context, slots, caseText) {
  const facts = extractEnhancedFacts(caseText);
  const urgency = context.urgency || false;
  const stressLevel = context.stressLevel || 'low';
  
  let openingTone = "I am writing to apply for";
  if (urgency || stressLevel === 'high') {
    openingTone = "I am writing to urgently apply for";
  }
  
  let personalCircumstances = "";
  if (context.keyConcerns?.includes('family_issues')) {
    personalCircumstances += "\n\nI am responsible for my family and this assistance would significantly help us during this difficult time.";
  }
  
  if (context.keyConcerns?.includes('employment_issues')) {
    personalCircumstances += "\n\nI am currently facing employment challenges and would greatly benefit from this support while I work to improve my situation.";
  }
  
  return `Dear ComCare Officer,

${openingTone} financial assistance under the ComCare scheme for my constituent.

CONSTITUENT'S SITUATION:
${facts.details || 'My constituent has provided detailed information regarding their current circumstances.'}

CIRCUMSTANCES OVERVIEW:
${facts.circumstances || 'My constituent would like to provide additional context regarding their current situation.'}${personalCircumstances}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

REQUEST FOR ASSISTANCE:
I respectfully request your consideration for financial assistance to help my constituent and their family during this challenging period.

My constituent is committed to working towards financial independence and would be grateful for your support during this transition.

Thank you for your time and consideration.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function extractEnhancedFacts(caseText) {
  const facts = {
    circumstances: '',
    details: '',
    timeline: '',
    impact: '',
    keyPoints: [],
    supportingEvidence: []
  };
  
  // Extract and professionally paraphrase circumstances
  const circumstancePatterns = [
    /(?:circumstances?|situation|context)[:\s]*(.+?)(?:\n|$)/gi,
    /(?:what happened|the issue|problem)[:\s]*(.+?)(?:\n|$)/gi
  ];
  
  circumstancePatterns.forEach(pattern => {
    const match = caseText.match(pattern);
    if (match) {
      facts.circumstances += professionalParaphrase(match[1]) + ' ';
    }
  });
  
  // Extract and paraphrase details
  const detailPatterns = [
    /(?:details?|information|facts?)[:\s]*(.+?)(?:\n|$)/gi,
    /(?:specifically|in particular)[:\s]*(.+?)(?:\n|$)/gi
  ];
  
  detailPatterns.forEach(pattern => {
    const match = caseText.match(pattern);
    if (match) {
      facts.details += professionalParaphrase(match[1]) + ' ';
    }
  });
  
  // Extract timeline information
  const timelinePatterns = [
    /(?:when|date|time|timeline)[:\s]*(.+?)(?:\n|$)/gi,
    /(?:occurred|happened)[:\s]*(.+?)(?:\n|$)/gi
  ];
  
  timelinePatterns.forEach(pattern => {
    const match = caseText.match(pattern);
    if (match) {
      facts.timeline += professionalParaphrase(match[1]) + ' ';
    }
  });
  
  // Extract impact information
  const impactPatterns = [
    /(?:impact|affect|consequence)[:\s]*(.+?)(?:\n|$)/gi,
    /(?:result|outcome)[:\s]*(.+?)(?:\n|$)/gi
  ];
  
  impactPatterns.forEach(pattern => {
    const match = caseText.match(pattern);
    if (match) {
      facts.impact += professionalParaphrase(match[1]) + ' ';
    }
  });
  
  // Enhanced compassionate circumstances extraction
  facts.compassionateCircumstances = extractCompassionateCircumstances(caseText);
  facts.familySituation = extractFamilySituation(caseText);
  facts.financialHardship = extractFinancialHardship(caseText);
  facts.jobSecurity = extractJobSecurityConcerns(caseText);
  
  // Priority classification
  facts.priorityAnalysis = classifyPriorityLevel(caseText, facts);
  
  // Additional help recommendations
  facts.additionalHelp = generateAdditionalHelpRecommendations(caseText, facts);
  
  // Extract key points for professional presentation
  facts.keyPoints = extractKeyPoints(caseText);
  facts.supportingEvidence = extractSupportingEvidence(caseText);
  
  // Clean up and format
  Object.keys(facts).forEach(key => {
    if (typeof facts[key] === 'string') {
      facts[key] = facts[key].trim().replace(/\s+/g, ' ');
      if (facts[key] && !facts[key].endsWith('.')) {
        facts[key] += '.';
      }
    }
  });
  
  return facts;
}

function professionalParaphrase(text) {
  // Convert informal language to professional tone
  const paraphrases = {
    // Urgency indicators
    'urgent': 'requires immediate attention',
    'asap': 'at the earliest opportunity',
    'quickly': 'expeditiously',
    'soon': 'in a timely manner',
    
    // Problem indicators
    'problem': 'issue',
    'issue': 'matter',
    'trouble': 'difficulty',
    'stuck': 'unable to proceed',
    'confused': 'unclear about the process',
    'lost': 'uncertain about next steps',
    
    // Financial indicators
    'can\'t afford': 'experiencing financial constraints',
    'no money': 'facing financial difficulties',
    'broke': 'experiencing financial hardship',
    'struggling': 'facing challenges',
    
    // Family indicators
    'kids': 'children',
    'wife': 'spouse',
    'husband': 'spouse',
    'family': 'household',
    
    // Time indicators
    'recently': 'in recent times',
    'lately': 'recently',
    'last week': 'the previous week',
    'this month': 'the current month',
    
    // Emotional indicators
    'frustrated': 'concerned',
    'angry': 'disappointed',
    'upset': 'concerned',
    'worried': 'concerned',
    'stressed': 'under pressure'
  };
  
  let paraphrased = text.toLowerCase();
  
  // Apply paraphrases
  Object.keys(paraphrases).forEach(key => {
    const regex = new RegExp(`\\b${key}\\b`, 'gi');
    paraphrased = paraphrased.replace(regex, paraphrases[key]);
  });
  
  // Capitalize first letter
  paraphrased = paraphrased.charAt(0).toUpperCase() + paraphrased.slice(1);
  
  return paraphrased;
}

function extractKeyPoints(caseText) {
  const keyPoints = [];
  const text = caseText.toLowerCase();
  
  // Enhanced financial amount extraction with context
  const financialPatterns = {
    fine: /(?:fine|penalty|summon).*?\$([\d,]+)/gi,
    salary: /(?:salary|wage|earn|take home|take-home).*?\$([\d,]+)/gi,
    income: /(?:income|before cpf|cpf deduction).*?\$([\d,]+)/gi,
    demerit: /(?:demerit|points).*?(\d+)/gi
  };
  
  // Extract fine amount
  const fineMatches = caseText.match(financialPatterns.fine);
  if (fineMatches) {
    fineMatches.forEach(match => {
      const amount = match.match(/\$([\d,]+)/);
      if (amount) {
        keyPoints.push(`Fine amount: $${amount[1]}`);
      }
    });
  }
  
  // Extract salary information
  const salaryMatches = caseText.match(financialPatterns.salary);
  if (salaryMatches) {
    salaryMatches.forEach(match => {
      const amount = match.match(/\$([\d,]+)/);
      if (amount) {
        if (match.includes('take home') || match.includes('take-home')) {
          keyPoints.push(`Take-home salary: $${amount[1]}`);
        } else {
          keyPoints.push(`Monthly salary: $${amount[1]}`);
        }
      }
    });
  }
  
  // Extract income before CPF
  const incomeMatches = caseText.match(financialPatterns.income);
  if (incomeMatches) {
    incomeMatches.forEach(match => {
      const amount = match.match(/\$([\d,]+)/);
      if (amount) {
        keyPoints.push(`Salary before CPF: $${amount[1]}`);
      }
    });
  }
  
  // Extract demerit points
  const demeritMatches = caseText.match(financialPatterns.demerit);
  if (demeritMatches) {
    demeritMatches.forEach(match => {
      const points = match.match(/(\d+)/);
      if (points) {
        keyPoints.push(`Demerit points: ${points[1]}`);
      }
    });
  }
  
  // Extract dates
  const dateMatches = caseText.match(/\b\d{1,2}\/\d{1,2}\/\d{2,4}\b|\b\d{4}-\d{2}-\d{2}\b|\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi);
  if (dateMatches) {
    dateMatches.forEach(date => {
      keyPoints.push(`Relevant date: ${date}`);
    });
  }
  
  // Extract reference numbers
  const refMatches = caseText.match(/\b[A-Z0-9]{6,}\b/g);
  if (refMatches) {
    refMatches.forEach(ref => {
      keyPoints.push(`Reference number: ${ref}`);
    });
  }
  
  // Extract locations
  const locationMatches = caseText.match(/\b(?:singapore|sengkang|tampines|jurong|woodlands|clementi|bishan|ang mo kio|toa payoh|hougang|punggol|sembawang|yishun|choa chu kang|bukit batok|bukit panjang|queenstown|redhill|telok blangah|pasir ris|bedok|eunos|kallang|geylang|marine parade|katong|east coast|tanjong pagar|chinatown|little india|orchard|novena|newton|bishan|ang mo kio|serangoon|hougang|punggol|sengkang|tampines|pasir ris|bedok|eunos|kallang|geylang|marine parade|katong|east coast|tanjong pagar|chinatown|little india|orchard|novena|newton)\b/gi);
  if (locationMatches) {
    locationMatches.forEach(location => {
      keyPoints.push(`Location: ${location}`);
    });
  }
  
  return keyPoints;
}

// Enhanced compassionate circumstances extraction
function extractCompassionateCircumstances(caseText) {
  const circumstances = [];
  const text = caseText.toLowerCase();
  
  // Sole breadwinner detection
  if (text.includes('sole breadwinner') || text.includes('only breadwinner')) {
    circumstances.push('Sole breadwinner of the household');
  }
  
  // Family dependency
  if (text.includes('three kids') || text.includes('3 kids') || text.includes('three children')) {
    circumstances.push('Parent of three children');
  }
  
  // Spouse health issues
  if (text.includes('wife') && (text.includes('unable to work') || text.includes('health') || text.includes('sick'))) {
    circumstances.push('Spouse unable to work due to health reasons');
  }
  
  // Financial constraints
  if (text.includes('barely enough') || text.includes('struggling') || text.includes('difficult')) {
    circumstances.push('Experiencing significant financial constraints');
  }
  
  return circumstances;
}

function extractFamilySituation(caseText) {
  const family = [];
  const text = caseText.toLowerCase();
  
  // Children count
  const childrenMatch = text.match(/(?:three|3|four|4|five|5|six|6)\s+(?:kids|children)/);
  if (childrenMatch) {
    family.push(`Parent of ${childrenMatch[1]} children`);
  }
  
  // Spouse situation
  if (text.includes('wife') && text.includes('unable to work')) {
    family.push('Spouse unable to work due to health reasons');
  }
  
  // Family dependency
  if (text.includes('depend') || text.includes('rely on')) {
    family.push('Family members dependent on constituent');
  }
  
  return family;
}

function extractFinancialHardship(caseText) {
  const hardship = [];
  const text = caseText.toLowerCase();
  
  // Income vs fine ratio
  const fineMatch = text.match(/\$?(\d+).*?(?:fine|penalty)/);
  const salaryMatch = text.match(/\$?(\d+).*?(?:take home|take-home)/);
  
  if (fineMatch && salaryMatch) {
    const fine = parseInt(fineMatch[1]);
    const salary = parseInt(salaryMatch[1]);
    const ratio = Math.round((fine / salary) * 100);
    hardship.push(`Fine represents ${ratio}% of monthly take-home salary`);
  }
  
  // Financial struggle indicators
  if (text.includes('barely enough') || text.includes('struggling')) {
    hardship.push('Monthly income barely covers household expenses');
  }
  
  if (text.includes('unable to pay')) {
    hardship.push('Unable to pay the fine due to financial constraints');
  }
  
  return hardship;
}

function extractJobSecurityConcerns(caseText) {
  const concerns = [];
  const text = caseText.toLowerCase();
  
  // Job loss risk
  if (text.includes('lose my job') || text.includes('lose job')) {
    concerns.push('Risk of job loss due to demerit points');
  }
  
  // Driver-specific concerns
  if (text.includes('driver') && text.includes('only work')) {
    concerns.push('Driving is the only skill set available for employment');
  }
  
  // License suspension
  if (text.includes('demerit') && text.includes('points')) {
    concerns.push('Demerit points may result in license suspension');
  }
  
  return concerns;
}

// Priority Classification System
function classifyPriorityLevel(caseText, facts) {
  const text = caseText.toLowerCase();
  const priorities = {
    immediate: [],
    medium: [],
    low: []
  };
  
  // IMMEDIATE ACTION indicators
  if (text.includes('sole breadwinner') || text.includes('only breadwinner')) {
    priorities.immediate.push('Sole breadwinner status - family welfare at risk');
  }
  
  if (text.includes('lose my job') || text.includes('lose job')) {
    priorities.immediate.push('Job security at risk - immediate income loss threat');
  }
  
  // Check fine to salary ratio
  const fineMatch = text.match(/\$?(\d+).*?(?:fine|penalty)/);
  const salaryMatch = text.match(/\$?(\d+).*?(?:take home|take-home)/);
  if (fineMatch && salaryMatch) {
    const fine = parseInt(fineMatch[1]);
    const salary = parseInt(salaryMatch[1]);
    const ratio = (fine / salary) * 100;
    if (ratio > 30) {
      priorities.immediate.push(`Financial crisis - fine represents ${Math.round(ratio)}% of monthly income`);
    }
  }
  
  if (text.includes('unable to pay')) {
    priorities.immediate.push('Unable to pay fine - immediate financial hardship');
  }
  
  if (text.includes('three kids') || text.includes('3 kids')) {
    priorities.immediate.push('Three children dependent - family stability at risk');
  }
  
  // MEDIUM PRIORITY indicators
  if (text.includes('wife') && text.includes('unable to work')) {
    priorities.medium.push('Spouse health issues - long-term care needs');
  }
  
  if (text.includes('driver') && text.includes('only work')) {
    priorities.medium.push('Limited employment options - need alternative job placement');
  }
  
  if (text.includes('demerit') && text.includes('points')) {
    priorities.medium.push('License suspension risk - transportation challenges');
  }
  
  if (text.includes('barely enough') || text.includes('struggling')) {
    priorities.medium.push('Financial counseling needed - budget management support');
  }
  
  // LOW PRIORITY indicators
  if (text.includes('traffic') || text.includes('offence')) {
    priorities.low.push('Traffic education - defensive driving courses');
  }
  
  if (text.includes('cpf') || text.includes('salary')) {
    priorities.low.push('Financial planning - CPF optimization advice');
  }
  
  return priorities;
}

// Additional Help Recommendations using NLP
function generateAdditionalHelpRecommendations(caseText, facts) {
  const text = caseText.toLowerCase();
  const recommendations = {
    immediate: [],
    medium: [],
    low: [],
    governmentServices: [],
    followUpActions: []
  };
  
  // IMMEDIATE HELP AREAS
  
  // Financial crisis detection
  if (text.includes('unable to pay') || text.includes('can\'t afford')) {
    recommendations.immediate.push({
      area: 'Financial Crisis Intervention',
      issue: 'Unable to pay fine due to financial constraints',
      help: 'Emergency financial assistance, payment plan arrangements',
      agency: 'ComCare, Social Service Office',
      urgency: 'IMMEDIATE'
    });
  }
  
  // Job loss risk detection
  if (text.includes('lose my job') || text.includes('lose job')) {
    recommendations.immediate.push({
      area: 'Job Security Protection',
      issue: 'Risk of job loss due to demerit points',
      help: 'License suspension appeal, alternative employment support',
      agency: 'Traffic Police, Workforce Singapore',
      urgency: 'IMMEDIATE'
    });
  }
  
  // Family welfare detection
  if (text.includes('sole breadwinner') && text.includes('kids')) {
    recommendations.immediate.push({
      area: 'Family Welfare Support',
      issue: 'Sole breadwinner with dependent children',
      help: 'Family support services, childcare assistance',
      agency: 'MSF, Social Service Office',
      urgency: 'IMMEDIATE'
    });
  }
  
  // MEDIUM PRIORITY HELP AREAS
  
  // Healthcare support detection
  if (text.includes('unable to work') && (text.includes('health') || text.includes('sick'))) {
    recommendations.medium.push({
      area: 'Healthcare Support',
      issue: 'Spouse unable to work due to health reasons',
      help: 'Medical assistance, disability support, caregiver support',
      agency: 'MOH, AIC (Agency for Integrated Care)',
      urgency: 'MEDIUM'
    });
  }
  
  // Employment diversification detection
  if (text.includes('only work') || text.includes('only job')) {
    recommendations.medium.push({
      area: 'Employment Diversification',
      issue: 'Limited to single skill set',
      help: 'Skills training, job placement, career counseling',
      agency: 'Workforce Singapore, SkillsFuture',
      urgency: 'MEDIUM'
    });
  }
  
  // Financial management detection
  if (text.includes('barely enough') || text.includes('struggling')) {
    recommendations.medium.push({
      area: 'Financial Management',
      issue: 'Income barely covers expenses',
      help: 'Budget counseling, debt management, financial planning',
      agency: 'Credit Counselling Singapore, Social Service Office',
      urgency: 'MEDIUM'
    });
  }
  
  // LOW PRIORITY HELP AREAS
  
  // Traffic education detection
  if (text.includes('traffic') || text.includes('offence') || text.includes('demerit')) {
    recommendations.low.push({
      area: 'Traffic Education',
      issue: 'Need to prevent future violations',
      help: 'Defensive driving courses, traffic safety education',
      agency: 'Traffic Police, Driving Schools',
      urgency: 'LOW'
    });
  }
  
  // CPF optimization detection
  if (text.includes('cpf') || text.includes('before cpf')) {
    recommendations.low.push({
      area: 'CPF Optimization',
      issue: 'CPF planning and optimization',
      help: 'CPF planning, retirement planning advice',
      agency: 'CPF Board, Financial Advisory Services',
      urgency: 'LOW'
    });
  }
  
  // GOVERNMENT SERVICES RECOMMENDATIONS
  recommendations.governmentServices = [
    'ComCare Financial Assistance',
    'Workfare Income Supplement (WIS)',
    'SkillsFuture Credit for training',
    'Workforce Singapore job placement',
    'AIC caregiver support services',
    'MSF family support services'
  ];
  
  // FOLLOW-UP ACTIONS
  recommendations.followUpActions = [
    'Schedule follow-up meeting in 2 weeks',
    'Connect with relevant government agencies',
    'Provide contact information for support services',
    'Monitor case progress and outcomes',
    'Offer ongoing assistance and guidance'
  ];
  
  return recommendations;
}

// Subject Line Generation
function generateSubjectLine(category, facts, slots) {
  const today = new Date().toISOString().slice(0, 10);
  
  // Traffic fines specific subject
  if (category === 'transport' && slots?.transport?.traffic_fines) {
    const trafficData = slots.transport.traffic_fines;
    const refNumber = trafficData.notice_number || trafficData.reference || 'TBD';
    const offenceType = trafficData.offence_type || 'Traffic Offence';
    return `Appeal for Traffic Fine - Ref: ${refNumber} - ${offenceType} - ${today}`;
  }
  
  // HDB appeals
  if (category === 'housing' && slots?.housing?.hdb_appeals) {
    const hdbData = slots.housing.hdb_appeals;
    const refNumber = hdbData.reference_number || hdbData.application_id || 'TBD';
    return `HDB Appeal - Ref: ${refNumber} - ${today}`;
  }
  
  // ComCare applications
  if (category === 'social_support' && slots?.social_support?.comcare_applications) {
    const comcareData = slots.social_support.comcare_applications;
    const refNumber = comcareData.application_id || comcareData.reference || 'TBD';
    return `ComCare Application - Ref: ${refNumber} - ${today}`;
  }
  
  // Employment matters
  if (category === 'employment') {
    const refNumber = facts.keyPoints.find(point => point.includes('Reference'))?.split(': ')[1] || 'TBD';
    return `Employment Matter - Ref: ${refNumber} - ${today}`;
  }
  
  // Tax/Finance matters
  if (category === 'tax_finance') {
    const refNumber = facts.keyPoints.find(point => point.includes('Reference'))?.split(': ')[1] || 'TBD';
    return `Tax/Finance Matter - Ref: ${refNumber} - ${today}`;
  }
  
  // Utilities/Communications
  if (category === 'utilities_comms') {
    const refNumber = facts.keyPoints.find(point => point.includes('Reference'))?.split(': ')[1] || 'TBD';
    return `Utilities/Communications Matter - Ref: ${refNumber} - ${today}`;
  }
  
  // Generic fallback
  return `Constituent Matter - ${category.charAt(0).toUpperCase() + category.slice(1)} - ${today}`;
}

function extractSupportingEvidence(caseText) {
  const evidence = [];
  const text = caseText.toLowerCase();
  
  // Check for supporting documents mentioned
  if (text.includes('document') || text.includes('certificate') || text.includes('letter') || text.includes('receipt')) {
    evidence.push('Supporting documentation available');
  }
  
  // Check for witnesses
  if (text.includes('witness') || text.includes('saw') || text.includes('observed')) {
    evidence.push('Witness testimony available');
  }
  
  // Check for medical evidence
  if (text.includes('doctor') || text.includes('medical') || text.includes('hospital') || text.includes('clinic')) {
    evidence.push('Medical documentation available');
  }
  
  // Check for financial evidence
  if (text.includes('bank') || text.includes('statement') || text.includes('payslip') || text.includes('income')) {
    evidence.push('Financial documentation available');
  }
  
  return evidence;
}

function generateOriginalLetter(category, caseText, selectedLabels) {
  // Fallback to original letter generation logic
  return `Dear Sir/Madam,

I am writing to appeal/request assistance regarding the matter described below.

CASE DETAILS:
${caseText}

SELECTED CATEGORIES:
${selectedLabels.join(', ')}

I respectfully request your consideration of this matter and would appreciate any guidance on how to proceed.

Thank you for your time and consideration.

Yours sincerely,
[Your Name]`;
}

// Multi-modal letter generation functions
function generateUrgentLetter(context, slots, caseText, category) {
  const facts = extractEnhancedFacts(caseText);
  const today = new Date().toISOString().slice(0, 10);
  
  return `URGENT REQUEST - ${today}

Dear Sir/Madam,

I am writing to URGENTLY request your immediate attention and assistance regarding the following matter that requires expedited processing for my constituent.

CONSTITUENT'S URGENT SITUATION:
${facts.circumstances || 'My constituent has presented a matter that requires immediate attention due to time-sensitive circumstances.'}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

URGENT CIRCUMSTANCES:
${facts.impact || 'This matter requires immediate attention due to time-sensitive circumstances that significantly impact my constituent.'}

I understand the importance of proper procedures, but given the urgent nature of this situation, I respectfully request your expedited consideration and processing of this matter.

I am available to provide any additional information or documentation immediately and can be reached at [Contact Number] for any clarifications.

Thank you for your urgent attention to this matter.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function generateCompassionateLetter(context, slots, caseText, category) {
  const facts = extractEnhancedFacts(caseText);
  const today = new Date().toISOString().slice(0, 10);
  
  let personalCircumstances = "";
  if (context.keyConcerns?.includes('family_issues')) {
    personalCircumstances += "\n\nI am particularly concerned about the impact this situation has on my family, especially my children who depend on me.";
  }
  
  if (context.keyConcerns?.includes('financial_difficulties')) {
    personalCircumstances += "\n\nI am currently facing significant financial difficulties and this matter adds considerable stress to an already challenging situation.";
  }
  
  if (context.keyConcerns?.includes('health_issues')) {
    personalCircumstances += "\n\nI am also dealing with health issues that make this situation even more difficult to manage.";
  }
  
  // Generate subject line
  const subjectLine = generateSubjectLine(category, facts, slots);
  
  return `Subject: ${subjectLine}

Dear Sir/Madam,

I am writing to humbly request your compassionate consideration regarding the following matter on behalf of my constituent. I understand the importance of following proper procedures and my constituent takes full responsibility for their actions.

CONSTITUENT'S SITUATION:
${facts.circumstances || 'My constituent would like to provide additional context about their current situation.'}${personalCircumstances}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

COMPASSIONATE CIRCUMSTANCES:
${facts.compassionateCircumstances.length > 0 ? facts.compassionateCircumstances.map(circ => `• ${circ}`).join('\n') : '• Constituent facing challenging personal circumstances'}

FAMILY SITUATION:
${facts.familySituation.length > 0 ? facts.familySituation.map(fam => `• ${fam}`).join('\n') : '• Family circumstances require consideration'}

FINANCIAL HARDSHIP:
${facts.financialHardship.length > 0 ? facts.financialHardship.map(fin => `• ${fin}`).join('\n') : '• Financial constraints affecting ability to resolve matter'}

JOB SECURITY CONCERNS:
${facts.jobSecurity.length > 0 ? facts.jobSecurity.map(job => `• ${job}`).join('\n') : '• Employment stability at risk'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

PERSONAL CIRCUMSTANCES:
${facts.impact || 'My constituent is facing challenging circumstances that warrant compassionate consideration.'}

My constituent is committed to resolving this matter responsibly and would be deeply grateful for any consideration you can provide. I understand that everyone must follow the rules, but I hope you can see the human side of this situation.

PRIORITY ANALYSIS:
${facts.priorityAnalysis.immediate.length > 0 ? `IMMEDIATE ACTION REQUIRED:\n${facts.priorityAnalysis.immediate.map(item => `• ${item}`).join('\n')}\n\n` : ''}${facts.priorityAnalysis.medium.length > 0 ? `MEDIUM PRIORITY:\n${facts.priorityAnalysis.medium.map(item => `• ${item}`).join('\n')}\n\n` : ''}${facts.priorityAnalysis.low.length > 0 ? `LOW PRIORITY:\n${facts.priorityAnalysis.low.map(item => `• ${item}`).join('\n')}\n\n` : ''}

ADDITIONAL HELP RECOMMENDATIONS:
${facts.additionalHelp.immediate.length > 0 ? `IMMEDIATE ASSISTANCE NEEDED:\n${facts.additionalHelp.immediate.map(rec => `• ${rec.area}: ${rec.help} (Contact: ${rec.agency})`).join('\n')}\n\n` : ''}${facts.additionalHelp.medium.length > 0 ? `MEDIUM PRIORITY SUPPORT:\n${facts.additionalHelp.medium.map(rec => `• ${rec.area}: ${rec.help} (Contact: ${rec.agency})`).join('\n')}\n\n` : ''}${facts.additionalHelp.low.length > 0 ? `LONG-TERM SUPPORT:\n${facts.additionalHelp.low.map(rec => `• ${rec.area}: ${rec.help} (Contact: ${rec.agency})`).join('\n')}\n\n` : ''}

GOVERNMENT SERVICES AVAILABLE:
${facts.additionalHelp.governmentServices.map(service => `• ${service}`).join('\n')}

FOLLOW-UP ACTIONS:
${facts.additionalHelp.followUpActions.map(action => `• ${action}`).join('\n')}

My constituent is willing to work with you in any way possible to resolve this matter and would appreciate any guidance on how to proceed.

Thank you for taking the time to consider this situation with compassion and understanding.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function generateFormalAppealLetter(context, slots, caseText, category) {
  const facts = extractEnhancedFacts(caseText);
  const today = new Date().toISOString().slice(0, 10);
  
  return `FORMAL APPEAL - ${today}

Dear Sir/Madam,

I am writing to formally appeal the decision regarding the matter described below on behalf of my constituent. I believe there are grounds for reconsideration based on the circumstances and evidence provided.

CONSTITUENT'S CASE:
${facts.circumstances || 'My constituent believes there are valid grounds for appeal based on the following circumstances:'}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

EVIDENCE AND SUPPORTING DOCUMENTS:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent has supporting documentation and evidence that supports their case'}

LEGAL GROUNDS FOR APPEAL:
${facts.details || 'My constituent has provided detailed information that supports their appeal.'}

REQUEST FOR RECONSIDERATION:
I respectfully request that you reconsider this matter based on the evidence and circumstances outlined above. My constituent is prepared to provide any additional documentation or information that may be required.

I understand the importance of following proper procedures and my constituent is committed to working within the established framework to resolve this matter.

Thank you for your consideration of this formal appeal.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function generateFollowUpLetter(context, slots, caseText, category) {
  const facts = extractEnhancedFacts(caseText);
  const today = new Date().toISOString().slice(0, 10);
  
  return `FOLLOW-UP REQUEST - ${today}

Dear Sir/Madam,

I am writing to follow up on my previous correspondence regarding the matter described below on behalf of my constituent. I hope this finds you well.

CONSTITUENT'S CASE:
${facts.circumstances || 'My constituent has provided details regarding their ongoing matter.'}

KEY FACTS PRESENTED:
${facts.keyPoints.length > 0 ? facts.keyPoints.map(point => `• ${point}`).join('\n') : '• Detailed circumstances have been provided by the constituent'}

SUPPORTING EVIDENCE:
${facts.supportingEvidence.length > 0 ? facts.supportingEvidence.map(evidence => `• ${evidence}`).join('\n') : '• Constituent is prepared to provide additional documentation as required'}

PREVIOUS CORRESPONDENCE:
I previously submitted my constituent's case on [Previous Date] and am following up to check on the status and any updates regarding their request.

CURRENT STATUS:
I would greatly appreciate an update on the current status of my constituent's case and any next steps that may be required from their end.

My constituent remains committed to providing any additional information or documentation that may be needed and is available to discuss this matter further if required.

Thank you for your continued attention to this matter.

Yours faithfully,

[MP Name]
Member of Parliament for [Constituency]
[Contact Information]`;
}

function regenerateLetterWithType(category, letterId) {
  const letterType = qs('letterType').value;
  const caseText = qs('caseText').value;
  const context = state.chatContext || {};
  const slots = state.slots || {};
  
  let newLetter = '';
  
  switch(letterType) {
    case 'urgent':
      newLetter = generateUrgentLetter(context, slots, caseText, category);
      break;
    case 'compassionate':
      newLetter = generateCompassionateLetter(context, slots, caseText, category);
      break;
    case 'formal':
      newLetter = generateFormalAppealLetter(context, slots, caseText, category);
      break;
    case 'followup':
      newLetter = generateFollowUpLetter(context, slots, caseText, category);
      break;
    default:
      // Use enhanced letter generation
      const subCategory = 'general';
      newLetter = generateEnhancedLetter(category, subCategory, caseText, []);
  }
  
  // Update the letter display
  const letterDisplay = qs('letterDisplay');
  if (letterDisplay) {
    const preElement = letterDisplay.querySelector('pre');
    if (preElement) {
      preElement.textContent = newLetter;
    }
  }
  
  // Save the new letter
  persistence.saveLetter(letterId, newLetter);
}

// Display the generated letter
function displayLetter(category, letterContent, selectedLabels) {
  // Create or update letter display area
  let letterDisplay = qs('letterDisplay');
  if (!letterDisplay) {
    letterDisplay = document.createElement('div');
    letterDisplay.id = 'letterDisplay';
    letterDisplay.className = 'mt-6 p-4 bg-white rounded-lg border shadow-sm';
    qs('selectedCategoryDetails').appendChild(letterDisplay);
  }
  
  const categoryName = category.replace('_', ' ').toUpperCase();
  const caseText = qs('caseText').value.trim();
  const extractedFacts = extractKeyFacts(caseText, selectedLabels);
  
  // Generate unique ID for persistence
  const letterId = `letter_${category}_${Date.now()}`;
  
  // Save to persistence model
  persistence.saveLetter(letterId, letterContent);
  persistence.saveExplainability(letterId, selectedLabels, extractedFacts, state.preds?.scores || {});
  
  letterDisplay.innerHTML = `
    <div class="flex items-center justify-between mb-4">
      <h4 class="font-semibold text-lg text-blue-800">Generated Letter - ${categoryName}</h4>
              <div class="flex gap-2">
          <select id="letterType" class="bg-gray-100 border border-gray-300 rounded px-2 py-1 text-sm" onchange="regenerateLetterWithType('${category}', '${letterId}')">
            <option value="standard">Standard Letter</option>
            <option value="urgent">Urgent Request</option>
            <option value="compassionate">Compassionate Appeal</option>
            <option value="formal">Formal Appeal</option>
            <option value="followup">Follow-up Letter</option>
          </select>
          <button onclick="copyLetter()" class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700">
            Copy Letter
          </button>
          <button onclick="downloadLetter('${category}')" class="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700">
            Download
          </button>
          <button onclick="editLetter('${letterId}')" class="bg-amber-600 text-white px-3 py-1 rounded text-sm hover:bg-amber-700">
            Edit
          </button>
        </div>
    </div>
    <div class="bg-gray-50 p-4 rounded border">
      <pre class="whitespace-pre-wrap text-sm font-mono">${letterContent}</pre>
    </div>
    <div class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
      <div class="bg-blue-50 p-3 rounded border">
        <h5 class="font-medium text-blue-800 mb-2">Selected Categories</h5>
        <div class="space-y-1">
          ${selectedLabels.map(label => {
            const [mainCat, subCat] = label.split('/');
            const subCategoryName = subCat.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            return `<div class="text-sm text-blue-700">• ${subCategoryName}</div>`;
          }).join('')}
        </div>
      </div>
      <div class="bg-green-50 p-3 rounded border">
        <h5 class="font-medium text-green-800 mb-2">Extracted Facts</h5>
        <div class="space-y-1">
          ${extractedFacts.map(fact => `
            <div class="text-sm text-green-700 relative group">
              • ${fact}
              <div class="absolute left-0 top-0 -translate-y-full bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10 whitespace-nowrap">
                Fact extracted from case text using NLP patterns
              </div>
            </div>
          `).join('')}
        </div>
      </div>
    </div>
    <div class="mt-3 text-xs text-gray-500">
      <strong>Letter Generation Logic:</strong> MP voice template with paraphrased facts (no raw citizen text). 
      Addressee auto-selected by main category. Required fields validated before generation.
      <br><strong>Persistence:</strong> Letter and explainability bundle saved (ID: ${letterId}).
    </div>
  `;
}

// Copy letter to clipboard
function copyLetter() {
  const letterText = qs('letterDisplay').querySelector('pre').textContent;
  navigator.clipboard.writeText(letterText).then(() => {
    alert('Letter copied to clipboard!');
  }).catch(() => {
    alert('Failed to copy letter. Please select and copy manually.');
  });
}

// Download letter as text file
function downloadLetter(category) {
  const letterText = qs('letterDisplay').querySelector('pre').textContent;
  const fileName = `letter_${category}_${new Date().toISOString().slice(0, 10)}.txt`;
  
  const blob = new Blob([letterText], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
}

// Generate all letters for selected categories
function generateAllLetters() {
  const selectedCheckboxes = document.querySelectorAll('input[type="checkbox"][data-category]:checked');
  if (selectedCheckboxes.length === 0) {
    alert('Please select at least one sub-category for letter generation.');
    return;
  }
  
  const categorySelections = {};
  selectedCheckboxes.forEach(checkbox => {
    const category = checkbox.dataset.category;
    if (!categorySelections[category]) {
      categorySelections[category] = [];
    }
    categorySelections[category].push(checkbox.dataset.label);
  });
  
  console.log('Generating letters for categories:', categorySelections);
  
  // Generate letters for each category
  const caseText = qs('caseText').value.trim();
  let allLettersContent = '';
  
  Object.entries(categorySelections).forEach(([category, labels], index) => {
    const letterContent = generateLetterContent(category, labels, caseText);
    const categoryName = category.replace('_', ' ').toUpperCase();
    
    allLettersContent += `\n\n${'='.repeat(50)}\n`;
    allLettersContent += `LETTER ${index + 1}: ${categoryName}\n`;
    allLettersContent += `${'='.repeat(50)}\n\n`;
    allLettersContent += letterContent;
  });
  
  // Display all letters
  displayAllLetters(allLettersContent, categorySelections);
}

// Display all generated letters
function displayAllLetters(allLettersContent, categorySelections) {
  // Create or update letter display area
  let letterDisplay = qs('letterDisplay');
  if (!letterDisplay) {
    letterDisplay = document.createElement('div');
    letterDisplay.id = 'letterDisplay';
    letterDisplay.className = 'mt-6 p-4 bg-white rounded-lg border shadow-sm';
    qs('selectedCategoryDetails').appendChild(letterDisplay);
  }
  
  const categoryCount = Object.keys(categorySelections).length;
  letterDisplay.innerHTML = `
    <div class="flex items-center justify-between mb-4">
      <h4 class="font-semibold text-lg text-blue-800">Generated Letters - ${categoryCount} Categories</h4>
      <div class="flex gap-2">
        <button onclick="copyAllLettersContent()" class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700">
          Copy All Letters
        </button>
        <button onclick="downloadAllLetters()" class="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700">
          Download All
        </button>
      </div>
    </div>
    <div class="bg-gray-50 p-4 rounded border max-h-96 overflow-y-auto">
      <pre class="whitespace-pre-wrap text-sm font-mono">${allLettersContent}</pre>
    </div>
    <div class="mt-3 text-sm text-gray-600">
      <strong>Generated for:</strong> ${Object.entries(categorySelections).map(([cat, labels]) => 
        `${cat.replace('_', ' ')} (${labels.length} items)`
      ).join(', ')}
    </div>
  `;
}

// Copy all letters to clipboard
function copyAllLettersContent() {
  const letterText = qs('letterDisplay').querySelector('pre').textContent;
  navigator.clipboard.writeText(letterText).then(() => {
    alert('All letters copied to clipboard!');
  }).catch(() => {
    alert('Failed to copy letters. Please select and copy manually.');
  });
}

// Download all letters as text file
function downloadAllLetters() {
  const letterText = qs('letterDisplay').querySelector('pre').textContent;
  const fileName = `all_letters_${new Date().toISOString().slice(0, 10)}.txt`;
  
  const blob = new Blob([letterText], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
}

// Edit letter function
function editLetter(letterId) {
  const letterData = persistence.getLetter(letterId);
  if (!letterData) return;
  
  const newContent = prompt('Edit letter content:', letterData.content);
  if (newContent !== null && newContent !== letterData.content) {
    persistence.saveLetter(letterId, newContent, { ...letterData.edits, lastEdit: Date.now() });
    
    // Update display
    const pre = qs('letterDisplay').querySelector('pre');
    if (pre) pre.textContent = newContent;
    
    // Update persistence info
    const info = qs('letterDisplay').querySelector('.text-xs.text-gray-500');
    if (info) {
      info.innerHTML = info.innerHTML.replace(/ID: [^)]+/, `ID: ${letterId} (edited)`);
    }
  }
}

function currentTruthSet() {
  // union of checked predictions + manually added
  return new Set([...state.checked, ...state.truthAdd]);
}

function updateMetrics() {
  const p = state.preds; if (!p) { qs('metricPRF').textContent = ''; return; }
  const pred = new Set(p.labels || []);
  const truth = currentTruthSet();
  let TP=0, FP=0, FN=0;
  pred.forEach(l => { if (truth.has(l)) TP++; else FP++; });
  truth.forEach(l => { if (!pred.has(l)) FN++; });
  const prec = TP + FP === 0 ? 0 : TP / (TP + FP);
  const rec  = TP + FN === 0 ? 0 : TP / (TP + FN);
  const f1   = (prec + rec) === 0 ? 0 : (2 * prec * rec) / (prec + rec);
  qs('metricPRF').textContent = `TP ${TP} · FP ${FP} · FN ${FN} — P ${(prec*100).toFixed(1)}% · R ${(rec*100).toFixed(1)}% · F1 ${(f1*100).toFixed(1)}%`;
}

/** ---------- CSV feedback ---------- */
function addTruth() {
  const v = qs('addTruth').value.trim();
  if (!v) return;
  state.truthAdd.add(v);
  qs('addTruth').value=''; updateMetrics();
}
function exportCSV() {
  const p = state.preds; if (!p) return;
  const row = {
    text: p.text || qs('caseText').value.trim(),
    predicted: (p.labels || []).join('|'),
    truth_checked: [...state.checked].join('|'),
    truth_added: [...state.truthAdd].join('|'),
    all_truth: [...currentTruthSet()].join('|'),
    scores: JSON.stringify(p.scores || {}),
    top_categories: JSON.stringify(p.top_categories || [])
  };
  const header = Object.keys(row).join(',');
  const data = Object.values(row).map(v => '"' + String(v).replaceAll('"','""') + '"').join(',');
  const csv = header + '\n' + data + '\n';
  downloadFile('mpsconnect_feedback.csv', csv, 'text/csv');
}
function downloadFile(name, content, mime='text/plain') {
  const blob = new Blob([content], {type: mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = name; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/** ---------- Letters with Approve/Edit/Reject ---------- */
function generateLetterTemplate(label, provider, fields, caseText) {
  const today = new Date().toISOString().slice(0,10);
  const pdpa = !!fields.pdpa;
  const ref = 'MPSC-' + Math.floor(Math.random()*1e6).toString().padStart(6,'0');
  let baseHdr = '';
  let refLine = '';
  if (pdpa) {
    refLine = `Reference: ${ref} (PDPA-safe, no PII)\n`;
  } else {
    baseHdr = `${fields.name ? fields.name : ''}${fields.nric ? ` (NRIC/FIN: ${fields.nric})` : ''}\n${fields.addr || ''}\n${fields.email ? `Email: ${fields.email}` : ''}${fields.phone ? `  Tel: ${fields.phone}` : ''}`;
  }
  const headerBlock = refLine + (baseHdr ? baseHdr + '\n\n' : '');
  const sal = 'Dear Sir/Madam,';
  const closing = `\n\nYours faithfully,\n${fields.name || ''}`;
  const desc = caseText || '';
  const provName = provider?.provider || 'the relevant agency';

  const T = {
    'social_support/comcare_short_mid_term': () => `Date: ${today}\n\n${headerBlock}\n\n${provName}\n\n${sal}\n\nRE: Application for ComCare Short-to-Medium Term Assistance\n\nI am writing to request financial assistance due to prolonged unemployment and arrears. Summary:\n• Prolonged unemployment.\n• Outstanding bills: utilities, S&CC, housing.\n• Immediate needs: basic expenses while seeking employment.\n\n${desc}\n\nI would be grateful for an expedited assessment and guidance on required documents.${closing}`,
    'employment/career_services_e2i': () => `Date: ${today}\n\n${headerBlock}\n\nNTUC e2i\n\n${sal}\n\nRE: Request for Career Coaching and Job Matching\n\nI seek support for job search, coaching and suitable training pathways.\n\nBackground:\n${desc}\n\nPlease advise the next appointment and documents to bring.${closing}`,
    'utilities_comms/electricity_spgroup': () => `Date: ${today}\n\n${headerBlock}\n\nSP Group\n\n${sal}\n\nRE: Appeal for Payment Arrangement — Electricity Account\n\nI request a payment plan to clear arrears during temporary financial hardship.\nAccount: [No], Service Address: [Address].\nProposed arrangement: [e.g., $X per month].${closing}`,
    'housing/town_council_scc_arrears': () => `Date: ${today}\n\n${headerBlock}\n\nTown Council\n\n${sal}\n\nRE: Appeal / Instalment Plan for S&CC Arrears\n\nI request to restructure outstanding Service & Conservancy Charges due to financial hardship.\nEstate/Block/Unit: [Blk XX, #XX-XX].${closing}`,
    'housing/hdb_loan_arrears': () => `Date: ${today}\n\n${headerBlock}\n\nHousing & Development Board\n\n${sal}\n\nRE: HDB Loan Arrears — Instalment/Deferment Request\n\nI am seeking an instalment plan / deferment while I secure employment.\nFlat address: [Blk/Street/Unit]. Loan ref: [if known].\n\nBackground:\n${desc}\n\nI will maintain future payments under the agreed schedule.${closing}`,
  };
  const f = T[label];
  return (f ? f() : `Date: ${today}\n\n${headerBlock}\n\n${provName}\n\n${sal}\n\nRE: Assistance Request\n\n${desc}\n\nThank you for your consideration.${closing}`);
}

function generateLetters() {
  const p = state.preds; if (!p) return;
  const selected = [...state.checked];
  const providers = p.providers || {};
  const fields = {
    name: (qs('fName') || {value: ''}).value.trim(),
    nric: (qs('fNRIC') || {value: ''}).value.trim(),
    email: (qs('fEmail') || {value: ''}).value.trim(),
    phone: (qs('fPhone') || {value: ''}).value.trim(),
    addr: (qs('fAddr') || {value: ''}).value.trim(),
    pdpa: (qs('pdpaSafe') || {checked: false}).checked
  };
  const caseText = qs('caseText').value.trim();
  const wrap = qs('lettersWrap');
  if (!wrap) return;
  wrap.innerHTML = '<h3 class="font-medium mb-3">Generated Letters</h3><div id="lettersContainer" class="space-y-4"></div>';
  selected.forEach(lab => {
    const prov = providers[lab] || {};
    const body = generateLetterTemplate(lab, prov, fields, caseText);
    const el = document.createElement('div');
    el.className = 'border rounded-lg p-3 bg-white';
    const rid = 'rej_' + Math.random().toString(36).slice(2);
    el.innerHTML = `
      <div class="flex items-center justify-between mb-2">
        <div>
          <div class="text-sm text-gray-500">Label</div>
          <div class="font-medium mono">${lab}</div>
          <div class="text-xs text-gray-500">${prov.provider ? 'Provider: ' + prov.provider : ''}</div>
        </div>
        <div class="flex gap-2">
          <button class="btn-green" data-act="approve">Approve</button>
          <button class="btn-amber" data-act="edit">Edit</button>
          <button class="btn-red" data-act="reject">Reject</button>
        </div>
      </div>
      <textarea class="w-full rounded-lg border px-3 py-2 mono" rows="12" data-role="letter">${body.replaceAll('<','&lt;')}</textarea>
      <div class="mt-2 hidden" data-role="reject-box">
        <label class="block text-sm text-gray-600 mb-1">Rejection reason / suggested label change</label>
        <input id="${rid}" class="w-full rounded-lg border px-3 py-2" placeholder="Explain why this letter/label is rejected and what should be used instead…" />
      </div>
      <div class="mt-2 flex gap-2">
        <button class="btn-ghost" data-act="copy">Copy</button>
        <button class="btn-ghost" data-act="download">Download .txt</button>
      </div>
    `;
    const ta = el.querySelector('[data-role=letter]');
    const rejBox = el.querySelector('[data-role=reject-box]');
    el.querySelector('[data-act=copy]').addEventListener('click', async () => {
      const text = ta.value; await navigator.clipboard.writeText(text);
    });
    el.querySelector('[data-act=download]').addEventListener('click', () => {
      const text = ta.value;
      const fname = lab.replaceAll('/','_') + '.txt';
      downloadFile(fname, text, 'text/plain');
    });
    el.querySelector('[data-act=approve]').addEventListener('click', () => {
      state.approvals[lab] = true;
      delete state.rejections[lab];
      rejBox.classList.add('hidden');
      el.classList.remove('bg-red-50');
      el.classList.add('bg-green-50');
    });
    el.querySelector('[data-act=edit]').addEventListener('click', () => {
      ta.focus();
    });
    el.querySelector('[data-act=reject]').addEventListener('click', () => {
      const input = document.getElementById(rid);
      rejBox.classList.remove('hidden');
      el.classList.remove('bg-green-50');
      el.classList.add('bg-red-50');
      setTimeout(() => input?.focus(), 0);
      input?.addEventListener('input', () => {
        state.rejections[lab] = input.value.trim();
        if (!state.rejections[lab]) delete state.rejections[lab];
      });
    });
    wrap.appendChild(el);
  });
}

function copyAllLetters() {
  const texts = [...document.querySelectorAll('#lettersWrap textarea[data-role=letter]')].map(t => t.value).join('\n\n---\n\n');
  if (texts) navigator.clipboard.writeText(texts);
}

/** ---------- Predict action ---------- */
async function predictOnce() {
  qs('errMsg').classList.add('hidden');
  saveSettings();
  const payload = {
    texts: [qs('caseText').value.trim()],
    threshold_top: parseFloat(qs('confidenceThreshold').value) || 0.1,
    threshold_child: parseFloat(qs('confidenceThreshold').value) || 0.1,
    top_k_top: parseInt(qs('maxCategories').value) || 6,
    top_k_child: parseInt(qs('maxSubCategories').value) || 10,
    top_k_total: (parseInt(qs('maxCategories').value) || 6) * (parseInt(qs('maxSubCategories').value) || 10),
    seed_prior_threshold: 0.44,
    use_priors: true,
    return_providers: true,
    return_confidence_breakdown: true
  };
  if (!payload.texts[0]) { qs('errMsg').textContent = 'Enter case text.'; qs('errMsg').classList.remove('hidden'); return; }
  
  console.log('Sending payload:', payload);
  try {
    const j = await apiFetch('/predict', { method: 'POST', body: JSON.stringify(payload) });
    renderPreds(j);
  } catch (e) {
    qs('errMsg').textContent = 'Predict failed: ' + (e?.message || e);
    qs('errMsg').classList.remove('hidden');
  }
}

/** ---------- Wire up ---------- */
initForm();
applyFeatureFlags();
// Add null checks for event listeners
const btnSave = qs('btnSave');
if (btnSave) btnSave.addEventListener('click', saveSettings);

const btnHealth = qs('btnHealth');
if (btnHealth) btnHealth.addEventListener('click', healthz);

const btnPredict = qs('btnPredict');
if (btnPredict) btnPredict.addEventListener('click', predictOnce);

const btnClear = qs('btnClear');
if (btnClear) {
  btnClear.addEventListener('click', () => {
    qs('caseText').value='';

    // Clear result containers safely
    const predBody = qs('predBody');
    if (predBody) predBody.innerHTML='';

    const topCats = qs('topCats');
    if (topCats) topCats.innerHTML='';

    const lettersWrap = qs('lettersWrap');
    if (lettersWrap) {
      lettersWrap.innerHTML = '<h3 class="font-medium mb-3">Generated Letters</h3><div id="lettersContainer" class="space-y-4"></div>';
      lettersWrap.classList.add('hidden');
    }

    state.preds=null; state.checked.clear();
    // keep truthAdd (human ground-truth additions) unless you want to clear:
    // state.truthAdd.clear();
    updateMetrics();
  });
}

// Chat mode event listeners
const toggleMode = qs('toggleMode');
if (toggleMode) toggleMode.addEventListener('click', toggleChatMode);

const btnSendChat = qs('btnSendChat');
if (btnSendChat) btnSendChat.addEventListener('click', sendChatMessage);

const btnResetChat = qs('btnResetChat');
if (btnResetChat) btnResetChat.addEventListener('click', resetChat);

const chatInput = qs('chatInput');
if (chatInput) {
  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendChatMessage();
    }
  });
  chatInput.addEventListener('input', () => {
    updateCharCount();
  });
}
// qs('btnAddTruth').addEventListener('click', addTruth); // Element doesn't exist - FIXED
// qs('btnExportCSV').addEventListener('click', exportCSV); // Element doesn't exist
// qs('btnGenLetters').addEventListener('click', generateLetters); // Element doesn't exist - FIXED
// qs('btnCopyAll').addEventListener('click', copyAllLetters); // Element doesn't exist - FIXED

// Chooser
const labelSearchEl = qs('labelSearch');
if (labelSearchEl) {
  labelSearchEl.addEventListener('input', renderLabelSearchResults);
  labelSearchEl.addEventListener('focus', loadLabelsOnce);
}
document.addEventListener('DOMContentLoaded', () => { loadLabelsOnce().catch(()=>{}); });

// If ?api= is present, auto-run a quick health check
if (qp.get('api')) { setTimeout(healthz, 200); }
</script>
</body>
</html>
