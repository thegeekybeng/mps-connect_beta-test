name: Deploy to Cloud Run (cloud_dev)

on:
  push:
    branches:
      - cloud_dev
  pull_request:
    branches:
      - cloud_dev
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID || 'mpsconnect-cw-pilot' }}
  REGION: ${{ secrets.GCP_REGION || 'asia-southeast1' }}
  REPO: ${{ secrets.ARTIFACT_REPO || 'mps-connect' }}
  SERVICE: mps-connect-api
  IMAGE_TAG: cloud-dev-${{ github.sha }}
  # Pre-deploy warm setting; default 0 to avoid cost unless explicitly set
  MIN_INSTANCES: ${{ secrets.CLOUD_RUN_MIN_INSTANCES || '0' }}
  # Mirror secrets to env so we can reference them in if: conditions
  WIF_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
  SA_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT }}
  SA_KEY: ${{ secrets.GCP_SA_KEY }}

jobs:
  build_pr:
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Docker build (syntax check)
        run: |
          docker build -f Dockerfile -t local/check:latest .

  deploy:
    if: ${{ github.event_name != 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    concurrency:
      group: cloud-run-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

      - name: Preflight build (Docker) and local boot test
        run: |
          set -e
          TAG="local/preflight:${GITHUB_SHA}"
          echo "Building ${TAG}"
          docker build -f Dockerfile -t "$TAG" .
          echo "Starting container for local health check"
          CID=$(docker run -d -e PORT=8080 -p 8080:8080 "$TAG")
          trap 'docker logs --tail=200 "$CID" || true; docker rm -f "$CID" || true' EXIT
          for i in {1..60}; do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8080/healthz || true)
            if [ "$CODE" = "200" ]; then echo "Local health OK"; break; fi
            sleep 2
          done
          if [ "$CODE" != "200" ]; then echo "Local container did not become healthy"; exit 1; fi
          docker rm -f "$CID" >/dev/null 2>&1 || true

      - name: Validate required secrets and files
        run: |
          : "${PROJECT_ID:?Missing GCP_PROJECT_ID secret}"
          : "${REGION:?Missing GCP_REGION (or default) secret}"
          : "${REPO:?Missing ARTIFACT_REPO (or default) secret}"
          test -f env.yaml || { echo "env.yaml missing in repo root"; exit 1; }

      - name: Require auth configuration (WIF or SA key)
        run: |
          if [ -z "${WIF_PROVIDER}" ] && [ -z "${SA_KEY}" ]; then
            echo "ERROR: No GCP auth configured." >&2
            echo "Set either (GCP_WORKLOAD_IDENTITY_PROVIDER + GCP_SERVICE_ACCOUNT) or GCP_SA_KEY in GitHub secrets." >&2
            exit 1
          fi

      - name: Budget / deploy guard
        id: budget
        env:
          DEPLOY_PAUSE: ${{ secrets.DEPLOY_PAUSE }}
          BUDGET_GUARD_ENABLED: ${{ secrets.BUDGET_GUARD_ENABLED }}
          BUDGET_MAX_MONTHLY_USD: ${{ secrets.BUDGET_MAX_MONTHLY_USD }}
          BUDGET_USAGE_URL: ${{ secrets.BUDGET_USAGE_URL }}
          BUDGET_USAGE_TOKEN: ${{ secrets.BUDGET_USAGE_TOKEN }}
        run: bash scripts/budget_guard.sh

      # Authenticate to Google Cloud - choose one method below
      # Method A: Workload Identity Federation (recommended)
      - name: Auth via Workload Identity Federation
        if: ${{ env.WIF_PROVIDER != '' && env.SA_EMAIL != '' }}
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ env.SA_EMAIL }}

      # Method B: Service Account Key (fallback)
      - name: Auth via Service Account Key
        if: ${{ env.WIF_PROVIDER == '' && env.SA_KEY != '' }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.SA_KEY }}

      - name: Setup gcloud
        if: ${{ steps.budget.outputs.continue != 'false' }}
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configure defaults
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          gcloud config set project "$PROJECT_ID"
          gcloud config set run/region "${REGION}"

      - name: Enable required services (best-effort)
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          gcloud services enable \
            run.googleapis.com \
            artifactregistry.googleapis.com \
            iam.googleapis.com \
            compute.googleapis.com || true

      - name: Ensure Artifact Registry repo
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          gcloud artifacts repositories describe "$REPO" --location="$REGION" \
            || gcloud artifacts repositories create "$REPO" \
                 --repository-format=docker \
                 --location="$REGION" \
                 --description="MPS Connect images"

      - name: Auth Docker to Artifact Registry
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

      - name: Build and push image (Docker)
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/${SERVICE}:${IMAGE_TAG}"
          echo "Building ${IMAGE_URI}"
          docker build -f Dockerfile -t "$IMAGE_URI" .
          echo "Pushing ${IMAGE_URI}"
          docker push "$IMAGE_URI"
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

      - name: Deploy to Cloud Run
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          # Grant artifact registry reader to runtime SA (idempotent)
          PROJECT_NUMBER=$(gcloud projects describe "$PROJECT_ID" --format='value(projectNumber)')
          RUNTIME_SA="${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"
          gcloud projects add-iam-policy-binding "$PROJECT_ID" \
            --member="serviceAccount:${RUNTIME_SA}" \
            --role="roles/artifactregistry.reader" \
            --quiet || true

          # Deploy with env from repo (ensure absolute paths)
          gcloud run deploy "$SERVICE" \
            --image "$IMAGE_URI" \
            --region "$REGION" \
            --allow-unauthenticated \
            --min-instances "${MIN_INSTANCES}" \
            --cpu 2 --memory 3Gi --timeout 300 \
            --max-instances 10 \
            --execution-environment gen2 \
            --env-vars-file env.yaml

      - name: Show service URL
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          URL=$(gcloud run services describe "$SERVICE" --region "$REGION" --format='value(status.url)')
          echo "Service URL: ${URL}"
          echo "SERVICE_URL=${URL}" >> $GITHUB_ENV

      - name: Health check
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          set -e
          URL="$SERVICE_URL"
          echo "Checking health at ${URL}/healthz"
          for i in {1..30}; do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "${URL}/healthz" || true)
            echo "Attempt $i: HTTP $CODE"
            if [ "$CODE" = "200" ]; then
              echo "Service healthy"; exit 0; fi
            sleep 5
          done
          echo "Service did not become healthy in time"; exit 1

      - name: Extract API key from env.yaml
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          # Parses a simple KEY: "value" line for API_KEY
          API_KEY=$(awk -F': ' '/^API_KEY:/ {gsub(/"/,"",$2); print $2}' env.yaml | tr -d '\r')
          if [ -z "$API_KEY" ]; then echo "API_KEY not found in env.yaml"; exit 1; fi
          echo "API_KEY=$API_KEY" >> $GITHUB_ENV

      - name: Smoke test /labels
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          set -e
          URL="$SERVICE_URL"
          echo "GET ${URL}/labels"
          RESP=$(curl -fsS "${URL}/labels")
          COUNT=$(echo "$RESP" | jq '.labels | length')
          if [ -z "$COUNT" ] || [ "$COUNT" -lt 1 ]; then
            echo "No labels returned"; echo "$RESP"; exit 1; fi
          echo "Labels OK: $COUNT"

      - name: Smoke test /predict
        if: ${{ steps.budget.outputs.continue != 'false' }}
        run: |
          set -e
          URL="$SERVICE_URL"
          API_KEY="$API_KEY"
          echo "POST ${URL}/predict"
          BODY='{"texts":["Need help with HDB housing and financial assistance"],"top_k_top":2,"top_k_child":2,"top_k_total":4}'
          RESP=$(curl -fsS -H "Content-Type: application/json" -H "X-API-Key: ${API_KEY}" -d "$BODY" "${URL}/predict")
          CNT=$(echo "$RESP" | jq '.predictions | length')
          LAB_CNT=$(echo "$RESP" | jq '.predictions[0].labels | length')
          if [ "${CNT:-0}" -lt 1 ] || [ "${LAB_CNT:-0}" -lt 1 ]; then
            echo "Predict failed"; echo "$RESP"; exit 1; fi
          echo "Predict OK: labels=$LAB_CNT"
